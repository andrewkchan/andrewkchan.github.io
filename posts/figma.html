<!DOCTYPE html><html><head>
  <title>Learnings from Figma</title>
  <meta charset="utf-8">
  <!-- Google tag (gtag.js) -->
  <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HYB0C59DXR"></script>
  <!-- Sentry -->
  <script src="https://js.sentry-cdn.com/f27e96506d16307fa97dcc9442b50117.min.js" crossorigin="anonymous"></script>
  <script src="./template.v1.js"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-HYB0C59DXR');
  </script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
    <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>

    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-HYB0C59DXR"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-HYB0C59DXR');
    </script>

    <script type="text/front-matter">
      title: "Learnings from Figma"
      published: August 16, 2024
      authors:
      - Andrew Chan: http://andrewkchan.github.io
      affiliations:
      -
    </script>

    <style>
      .caption > i {
        font-size: 15px;
        line-height: 1.3em;
      }
      .compact-li li {
        margin-bottom: 0.5em;
      }
    </style>
  </head>
<body>
  <dt-article>
    <h1><a href="/" class="hero">Andrew Chan</a></h1>
  </dt-article>
  <hr>
  <article class="toyb-article">
  
  
  <toyb-draft></toyb-draft>
  
  <dt-article>
    <h1>Learnings from Figma</h1>
    <h2></h2>
    <dt-byline></dt-byline>
    <p>
      It's been a few months since I left Figma, so I thought I'd write down some reflections on my time there before I forget.
    </p>
    <h2>Why did I work at Figma?</h2>
    <p>
      The biggest reason was the product. A designer friend introduced me to it around 2017 when designing the website for my college club and there was nothing like it: 
      a fully-featured, highly opinionated design tool on the web with Google-docs-style single-source-of-truth, unprecedented smooth performance, and pixel-perfect rendering. 
      I'd been using Photoshop before then - not even Sketch!
    </p>
    <p>
      I also thought the engineering team was exceptional: they knew what they were talking about in their blog posts, which showed both a willingness to take technical risks and an ability to
      carry them all the way through. It wasn't just one or two gems either; the blog was full of them. Here are some of my favorites:
      </p><ul class="compact-li">
        <li><a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">Building a professional design tool on the web</a></li>
        <li><a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/">How Figma's multiplayer technology works</a></li>
        <li><a href="https://www.figma.com/blog/realtime-editing-of-ordered-sequences/">Realtime editing of ordered sequences</a></li>
        <li><a href="https://www.figma.com/blog/introducing-vector-networks/">Introducing vector networks</a></li>
        <li><a href="https://www.figma.com/blog/rust-in-production-at-figma/">Rust in production at Figma</a></li>
      </ul>
    <p></p>
    <p>
      Before I made my final decision on where to go after college, I "reverse interviewed" a bunch of people from every company that accepted me, asking everyone questions like 
      "how would you characterize the growth of $COMPANY" and "why did you choose $COMPANY over others".
    </p>
    <p>
      I don't think this influenced my decision too much, because Figma's product and engineering blog had already won me over, although it made me more excited that people were easy to talk to and
      it seemed like a culture fit. I was also impressed with how incisive some of the answers to my business-related questions were from Figma employees, which showed that they had thought about the same things
      that I did and made a rational decision to bet on Figma. Finally, Figma actually gave me the most reverse interviewees, so I had the clearest picture of what working there was actually like as opposed to 
      the other companies I was considering at the time.
    </p>
    <h2>What did I do at Figma?</h2>
    <p>
      I joined in 2019 when Figma had less than 100 employees and I think ~40 engineers. When I left in early 2024, we'd grown to over 1500 employees.
    </p>
    <p>
      I started out as a product engineer on several projects in Figma Design like animations and interactive/variant components.
      But most of my work was as a platform engineer in the core engine. Some highlights:
      </p><ul class="compact-li">
        <li>
          I put the C++ engine used by our editor into our mobile app. One of the cooler technologies we developed as part of this was a 
          high-performance API from WASM/C++ to TypeScript.
        </li>
        <li>
          I helped migrate all code written in our <a href="/posts/skew.html">custom programming language</a> to Typescript with an automated migration.
        </li>
        <li>
          I worked on the stability of our mobile app a bunch, implementing optimizations from incremental document loading to binary serialization improvements.
        </li>
        <li>
          I also worked on the rendering performance of our whiteboarding tool. We managed to double FPS in intensive multiplayer scenarios by doing some 
          trickery with time-sliced rendering.
        </li>
      </ul>
    <p></p>
    <p>
      I also got to contribute to a few blog posts. Two of these I wrote a big chunk of and the third I was lucky enough to get a credit despite not really adding much:
      </p><ul class="compact-li">
        <li><a href="https://www.figma.com/blog/figmas-journey-to-typescript-compiling-away-our-custom-programming-language/">Figma's Journey to Typescript: Compiling Away Our Custom Programming Language</a></li>
        <li><a href="https://www.figma.com/blog/incremental-frame-loading/">Improving Performance With Incremental Frame Loading</a></li>
        <li><a href="https://www.figma.com/blog/keeping-figma-fast/#improving-rendering-performance">Keeping Figma Fast</a></li>
      </ul>
    <p></p>
    <h2>Why did Figma succeed in design?</h2>
    <p>Lots of folks have written about this. Here's my take as someone who didn't get to sit in boardrooms or peer at growth metrics, but did get to sit through some of the action.</p>
    <p>
      It's easy to say of course we were bound to win, since we were the first to do Google Docs for design, fixing the versioning, sharing, collaboration, and device problem all at the same time.
      And as an outsider to design it felt like a no-brainer to me before joining, too. But looking carefully at the industry as a whole in 2015-2020, I think our destiny wasn't so obvious.
    </p>
    <p>
      First, it wasn't immediately obvious that “Google docs for design” was something designers actually wanted. There's a now-infamous top comment from the Designer News article for Figma's launch that 
      went something like: “If this is the future of design, I'm changing careers.”<dt-fn>Up there with the "why wouldn't I just use rsync" comment in the HN thread launching Dropbox for asking for faster horses!</dt-fn>
    </p>
    <p>
      Second, it wasn't clear that Figma's browser-first approach to collaboration was enough of a moat.
      Yes, Figma links were a huge improvement over old design workflows and our product was spreading fast, but our competitors were racing to copy our features with Sketch Cloud and Adobe XD Cloud 
      Documents. XD had better prototyping and the vast resources of Adobe, while Sketch had pre-existing mindshare and was beginning to take venture capital. It's not hard to see a world where we ended 
      up in the same situation as Google Docs did with Office 365. There were also potential paradigm shifting players like Framer, in which designs were real React elements that designers could 
      manipulate directly.
    </p>
    <p>
      In the end, I think what made us win was that:
      </p><ul class="compact-li">
        <li>
          Browser-first link sharing let us convert non-designers (see <a href="https://kwokchain.com/2020/06/19/why-figma-wins/">Kevin Kwok's excellent <i>Why Figma Wins</i> from 2020</a>). This combined with 
          sticky features like design systems gave us powerful winner-take-all network effects.
        </li>
        <li>
          Our multiplayer technology turned out to be pretty hard for Adobe and Sketch to copy<dt-fn>Even in 2024, "design files not syncing properly" is one of the first results when I search for "Sketch Cloud".</dt-fn>. I would guess that this was less of a “collaborative algorithms are really hard to implement” and more of a 
          “existing products are really hard to make collaborative because legacy workflows impose extra edge cases” problem: Framer moved to browser-based collaboration pretty successfully, but it did so by 
          completely ditching its old product, and Figma-like design collaborative design tools created from scratch are pretty common these days.
        </li>
      </ul>
    <p></p>
    <p>
      With all that said, it still took some pretty incredible engineering to not only successfully build design experience in the web, but to make it world-class and be the first folks to do it, too.
      As I suggested above, I think one of the biggest reasons we were able to gather so much engineering talent is because of how much the company blogged early on about the interesting problems they 
      were encountering and how they were solving them. Of course, it also helps that Figma took huge amounts of venture funding and leveraged Silicon Valley networks while Sketch spent years as a
      bootstrapped business in the EU.
    </p>
    <h2>What else did Figma try when I was there and how do I think they did?</h2>
    <p>
      <b>Community</b>. This was originally supposed to make us the "Github for Design". I think we have probably not met those lofty goals, but the community is a great place to find pre-build assets
      and useful plugins. Even as someone who only dabbles in design I find it pretty useful: just a week ago I used it to find some AWS icons for an architecture diagram. That said, I don't use some of 
      the more fully featured assets like design systems, so I can't speak to how well those work.
    </p>
    <p>
      <b>Dev mode</b>. I'm not a frontend engineer<dt-fn>At least in the sense that I don't often write user-facing UI code. But a lot of my work was in the client-side codebase.</dt-fn>, so I don't have much to share about dev mode, having not used it very much. 
      However, I will note that aside from the new mode itself, Figma has had code generation for the web/Android/iOS for a long time, but as an afterthought, and with the release of dev mode,
      the team finally started paying more attention to that feature, and I have heard that it improved dramatically (particularly with the generated CSS containing proper layouts).
    </p>
    <p>
      <b>FigJam</b>. I think the team knocked it out of the park with this one. Yes, it's essentially just a skin over Figma Design, but FigJam is one of the most polished, delightful products 
      I've used (obviously I am biased). Everything has been carefully designed, from the little animations when you drag a sticky into the canvas to the FPS you get when moving your mouse over the icons
      in the toolbar.
    </p>
    <p>
      That said, business-wise, we faced more entrenched incumbents with FigJam, and our tech didn't give us much of a competitive advantage here: Miro et al. were already on the web, and while our 
      rendering tech still made us more performant in some cases, it also held us back, since it meant we couldn't bring in native UI functionality like videos and iframes as easily. We haven't won in this space, 
      at least not yet.
    </p>
    <p>
      <b>Slides</b>. Figma Slides was prototyped at maker week years ago, but didn't become a real initiative until my last half-year or so at Figma. I'm pleasantly surprised by how polished the 
      product is and how well-received it has been by the community (<a href="https://news.ycombinator.com/item?id=40802676">HN thread</a>) - personally, I didn't think it would be as successful 
      as it has been or why people would use it over tools like Google Slides. But maybe I just don't understand all the ways people use (or want to use) slides and the pain points with products today.
    </p>
    <p>
      There are also some other cool projects that I won't talk about because they're not out yet!
    </p>
    <h2>What technical things did I learn at Figma?</h2>
    <h3>Constraints of the web</h3>
    <p>
      The web's unparalleled distribution is a double-edged sword. It's a single platform with vast reach: not only is it write once, run anywhere for developers, but it's zero install, instant play for end users.
      But its universality means it moves slowly. In many ways it's a highly constrained, backwards platform only now catching up to decade-old developments in hardware and low-level technologies. For example:
      </p><ul class="compact-li">
        <li>
          <b>Multithreading</b>: This only became practical in the last few years. For a long time, web workers were a poor implementation, especially since SharedArrayBuffers were disabled across browsers from 2018-2020 
          due to security concerns, meaning message-passing was the only possible communication mechanism between workers.
        </li>
        <li>
          <b>64-bit memory</b>: As of July 2024 WebAssembly still only supports 32-bit addressing, meaning 4GB is the most memory you'll ever be able to work with, short of tricks like paging out to 
          JavaScript. In fact, even 4GB wasn't possible in Chrome until 2020 <a href="https://v8.dev/blog/4gb-wasm-memory">due to limitations in V8</a>.
        </li>
        <li>
          <b>SIMD</b>: This is still just a WebAssembly proposal, albeit one with decent support in the major browsers (just not older versions of iOS Safari!).
        </li>
        <li>
          <b>Screen recording and color picking</b>: <code>getDisplayMedia</code> only reached widespread support in mid 2019. This was relevant for the "eye dropper" functionality in design tools where you can click anywhere on the canvas to get the color value at that point.
          Previously, to use the eye dropper in Framer, you had to download the desktop version, but they eventually added the functionality via screen recording in Framer Web. The EyeDropper API was launched in late 2021 and is still only available in Chromium and Firefox browsers.
        </li>
        <li>
          <p>
            <b>Memory management</b>: Memory management on mobile especially is a <a href="https://github.com/WebAssembly/design/issues/1397">hot topic in the WebAssembly Community Group</a>.
          </p>
          <ul class="compact-li">
            <li>
              WASM memory is grow-only (although there is a <a href="https://github.com/WebAssembly/memory-control/blob/main/proposals/memory-control/Overview.md">memory control proposal</a> which would allow the application to release memory back 
              to the operating system), so bursts in activity grow application footprint permanently, making it much more likely to be killed over time.
            </li>
            <li>
              In practice, growing memory at runtime is notoriously unreliable on many mobile devices, with calls often leading to crashes, so the best practice is to allocate the maximum amount of memory that developers think their app 
              will use ahead-of-time.
            </li>
            <li>
              For Figma and many other apps with user-generated content or highly dynamic workloads, it's impossible to know this beforehand. So we'd simply over-allocate initially. This led to UX issues like the app being killed when 
              backgrounded on mobile when the workload wasn't actually all that high.
            </li>
          </ul>
        </li>
        <li>
          <b>Debugging and profiling</b>:
          <ul class="compact-li">
            <li>Ok, the Chrome profiler is amazing, and Chrome WASM Debugging via DWARF is quite good now!</li>
            <li>
              What wasn't so good was debugging on mobile Safari. Trying to debug memory and performance issues on Safari was very tricky. Recording profiles was finicky as the the timeline tool would sometimes only begin recording one type of timeline, 
              or start at weird times, or crash and reload, while other times the remote debugger would simply not show connected iPhones at all.
            </li>
            <li>
              This in combination with the memory management issues above and the trigger-happy OOM watchdog made the platform a nightmare for us to develop for. Around the time I left, 
              the mobile team hired some folks who had worked on Safari at Apple who had many tips (for instance, using the <code>footprint</code> app with the iOS simulator which gave more reliable measurements than attempting to use Safari tools on a physical device, 
              and was theoretically the same software), so I have some hope the situation is improved.
            </li>
          </ul>
        </li>
        <li>
          <b>GPU APIs</b>: 
          <ul class="compact-li">
            <li>
              As of writing, out of the major browsers, WebGPU is still only enabled by default on the Chromium-based ones (and only since last year). This is despite Metal (2014) being a decade old now (and CUDA from 2007
              being even older). So to build for the wider web, you have to use WebGL 2.0, which is based on OpenGL ES 3.0 from 2012, which is a pretty pale attempt at a modernization of the ancient OpenGL ES 2.0 standard from 2007,
              all of which lack proper GPGPU support!
            </li>
            <li>
              At Figma, we were lucky enough that the things we wanted to do on the GPU weren't all that complicated. This is not to say that the rendering tech we had wasn't advanced or that 2D vector rendering doesn't have anything
              interesting going on, it's just that fast-enough algorithms could be implemented fairly straightforwardly on older architectures with only vertex and fragment shaders, and beyond that, most use cases of our product
              would benefit more from optimizing other, more CPU-bound parts of the system.
            </li>
            <li>
              But if you need to write closer to the metal or do complex things with compute shaders, you're out of luck with WebGL, which not only lacks the latter but has to pass through an extra translation layer called ANGLE
              on almost all major web browsers which emulates OpenGL using the OS-native graphics API (which itself may have extra driver overhead on some platforms).
            </li>
          </ul>
        </li>
      </ul>
    <p></p>
    <p>
      What's interesting is that most software - even native software - doesn't take advantage of the hardware features listed above, and Figma was able to exploit this. It came out in 2015 using a web standard based on 8-year old 
      technology (WebGL) and <a href="https://medium.com/@evanwallace/easy-scalable-text-rendering-on-the-gpu-c3f4d782c5ac">GPU-based rendering algorithms</a> that were almost a decade old (<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/p1000-loop.pdf">Loop-Blinn</a> was invented in 2005),
      but Sketch - its MacOS native competitor - <a href="https://bjango.com/articles/perfsignatures/">barely even used the GPU</a>!
    </p>
    <h3>Design tools have multiplicative complexity</h3>
    <p>
      My colleague Rudi <a href="https://digitalfreepen.com/2018/09/29/figma-design-tools.html#:~:text=I%20can%20tell.-,Multiplicative%20complexity,-Back%20to%20how">pointed this out a while back</a>. Basically, when you're designing a set
      of primitives that all go in the same space (the canvas) which people are going to combine with each other to make things, everything needs to work with everything else.
    </p>
    <p>
      To illustrate this, let's imagine a simple version of Figma where we let people put rectangles and text on the canvas, change their color, and directly manipulate (select, move, and resize) them with the mouse. In the image below, 
      our app is shown with the layers panel on the left, the toolbar in the middle, and properties of the currently selected object (<code>Text 1</code>) on the right:
    </p>
    <img class="l-middle" src="./figma-assets/simplefigma1.png" alt="Simple Figma">
    <p>
      Already we have some questions:
      </p><ul class="compact-li">
        <li>What properties should we display in the right panel when you select <code>Text 1</code> and <code>Rect 1</code> together?</li>
        <li>When you resize your selection, should all elements scale uniformly, or should they resize like how you might resize a UI element, e.g. with the text staying the same size, just moving around?</li>
        <li>
          What happens when you resize a text object, or change its contents so that it gets too big for its current size? Should the “box” representing your selection stay the same with the characters just flowing outside of it, or should the box grow to fit, or should the characters within try to reflow to stay inside the box somehow?
        </li>
      </ul>
    <p></p>
    <p>
      We only have two types of objects and a handful of operations and info panels, yet we already need to consider how resizing can behave differently given object types, or how the right-hand panel might behave differently given heterogeneous selections. Some of these questions are more product-related (how resizing a selection of multiple objects should behave), while others 
      are more engineering-related (how we might efficiently handle reflowing large amounts of text). And this is all before we throw in multiplayer, auto-layout, and components!
    </p>
    <h2>What non-technical things did I learn at Figma?</h2>
    <h3>The Mythical Stakeholder Alignment</h3>
    <p>
      I spent my first couple years as a product engineer. I was not a very good product engineer.
    </p>
    <p>
      I had a habit of misunderstanding or interpreting ambiguous requirements in ways that increased scope (because of the same instincts that would lead me to work on the platform - everything had to be <i>clean</i> and <i>performant</i>!). But because I was good at fixing bugs fast and soaking up trivia about the codebase, 
      I was trusted by the team to take on larger projects and maybe mistakenly seen as a high performer.
    </p>
    <p>
      In my first year, this led to me working solo on a refactor which had to be scrapped after a few months because I thought it needed to support more than it actually needed to. At the time it felt catastrophic, but looking back it wasn't all that bad - it wasn't something especially important to the rest of the company but was a big learning moment for me.
    </p>
    <p>
      On the other hand, I suspect my stint as a poor product engineer made me a better platform engineer: I knew what it was like to interface with product and design folks, what they valued and how they communicated it, and how to use this to flush out the biggest risks and distill the highest priority requirements.
    </p>
    <p>
      For instance, in a later project I led that overhauled our whiteboarding renderer to improve FPS, while our initial idea (throttling canvas rendering to improve overall responsiveness) seemed concerning to basically everyone working on on-canvas features, we were able to quickly establish that the optimization could activate selectively and usefully, that 
      the critical times where it had to be disabled were few and far between, and that risks like system de-synchronization either weren't issues or could be easily mitigated.
    </p>
    <p>
      How did we do it? We talked to people! We held meetings and wrote docs, but also, since folks at Figma are big on seeing and trying things out, we built a demo, recorded videos demonstrating what magical terms like <i>system de-synchronization</i> actually looked like, and later when we landed it in staging, we built in a subtle UI indicator that would 
      appear to let folks know when our optimization was active.
    </p>
    <p>
      In other words, I had learned how do this mythical thing that people call “building alignment”: in a large company, where both the software and its use cases are too complex to fit in any one 
      person's head, I had enough of an understanding of the system being optimized to know when an idea (that someone else came up with!) was locally possible, and of the product and org (the connected 
      surfaces and the folks who understood them) to know or find out if it was globally possible, too.
    </p>
    <h3>Figma's engineering culture</h3>
    <p>
      <b>Importance of side projects</b>. At Figma, we had a culture that encouraged side projects - toys or programs that folks would create which nobody asked them to, which did not necessarily have an impact
      on the bottom line, but which could be used to explore new ideas or technologies. Many features and innovations came out of side projects. Just off the top of my head:
      </p><ul class="compact-li">
        <li>Our custom programming language, Skew</li>
        <li>Our internal offline document inspector, figmascope</li>
        <li>A performance profiling tool (also widely used outside of Figma), <a href="https://github.com/jlfwong/speedscope">speedscope</a></li>
        <li>The <a href="https://www.figma.com/widget-docs/figma-figjam-widgets/">widgets feature</a> where you could make React components that went on the Figma canvas</li>
        <li>Various <a href="https://www.figma.com/blog/april-fun-day-cursors/">April Fools features</a> like custom cursors</li>
        <li>The video feature of Figma prototypes</li>
      </ul>
    <p></p>
    <p>
      Two things made it work for us:
      </p><ul class="compact-li">
        <li>
          <p>
            The culture was fostered by leadership from the earliest days of the company. Indeed, it's part of Figma's mythos - in the San Francisco office, there's a coffee table sculpture of 
            the <a href="https://madebyevan.com/webgl-water/">"WebGL Water"</a> demo that Evan Wallace built back in 2010. And it wasn't just Evan - leaders would regularly take time out to play
            around with new ideas. For example:
          </p>
          <ul class="compact-li">
            <li>
              My first manager <a href="https://www.rykap.com/">Ryan</a> spent a lot of spare time getting deep into rendering of all kinds, from 
              <a href="https://www.rykap.com/2020/09/23/distance-fields/">WebGL</a> <a href="https://www.rykap.com/math/computer%20graphics/2017/04/11/compiling-shaders-on-the-fly/">rendering</a> 
              <a href="https://www.rykap.com/graphics/skew/2016/02/25/voronoi-diagrams/">techniques</a> that we didn't already use to exploring DOM-based renderers for Figma.
            </li>
            <li>
              Our product head <a href="https://x.com/skuwamoto">Sho</a> maintained a "toy Figma" built in React that he would use to quickly try out new ideas.
            </li>
          </ul>
        </li>
        <li>
          <p>
            We had time specifically set aside for side projects. Companies have different strategies for this: for instance, Google is famous for letting employees spend 20% of their time on 
            side projects. Our policies were a bit more ad-hoc, but we had both explicit time in the form of "maker weeks" and implicit time in the form of extra-long holidays<dt-fn>
            Obviously, you were not expected to do any work over the holidays, and I think now that we're a large company most people should and do use them for recharging. But work was not discouraged 
            either, and when you're heavily invested in a small startup and have nothing else going on...</dt-fn>.
          </p>
        </li>
      </ul>
    <p></p>
    <p>
      Why were side projects important to us?
      </p><ul class="compact-li">
        <li>
          It gave us time to explore new ideas or technologies without external pressure or requirement that they help our bottom line.
        </li>
        <li>
          The reserved time without interruptions let us go deep into our ideas and get spikier, which let us <a href="https://paulgraham.com/avg.html">beat the averages</a>.
        </li>
        <li>
          While less specific to side projects, prototyping things out to give people something concrete to play with helped us perfect design primitives before releasing them to the wider world.
          For instance, auto-layout actually existed for years behind a flag in the product (and was even reverse-engineered by Twitter at some point!). This is not to say that we didn't value iterating
          on public feedback, but that our product was complex enough that some features needed to be really thought through before release because of the multiplicative complexity of our product.
        </li>
      </ul>
    <p></p>
    <p>
      It's interesting contrasting our culture with the one that many of my ex-Dropboxer colleagues came from, where (I was told that) side projects were frowned upon because it meant 
      you weren't spending enough time working on your main project.
    </p>
    <p>
      Another interesting question is when side project culture doesn't add value anymore. As with so many things in company cultures, I think side projects don't really scale with company size.
      In the early days of a startup, folks are much more incentivized to spend their free time on exploring ideas that are genuinely relevant to the business, since they have a greater stake in
      its success. But in larger companies I'd guess that the ideas folks explore if given the opportunity would be more driven by what is better for their own careers, and only relevant to the company
      insofar as they fulfill "hack time" requirements and come from opportunities in the company's systems. There's also the classic innovator's dilemma where incumbents with precious existing businesses
      mmay feel pressure to be conservative and take less risks in revolutionary new ideas, hence tossing cold water on any side projects that might threaten the status quo.
    </p>
    <p>
      <b>Geeks attracted to a weird tech stack</b>. We had (and still have) a stellar team with lots of browser and graphics hackers who had cut their teeth in the 90s and 00s, I think because of our
      app's unique tech stack which made it like a <a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">browser within a browser</a> or an <a href="https://www.youtube.com/watch?v=opGoe7yHHkk">MMO</a>.
      For example, among my colleagues were a teammate who interned at Netscape and worked at Mozilla through the birth of the open web platform, and multiple other teammates who'd built videogames during the "masters of doom" early 3D era.
    </p>
    <p>
      <b>PRs as documentation</b>. PRs in my corner of Figma were specifically written with code archaeology in mind and providing context to changes line-by-line via git blame. 
      For a bugfix, a PR might include in its description:
      </p><ul class="compact-li">
        <li>What the bug was, who was running into it, and how important it was.</li>
        <li>Steps needed to manually test the fix and any automated tests that were added (or reasons they weren't added).</li>
        <li>Links to documentation, dashboards, or any other external resources that were updated.</li>
      </ul>
    <p></p>
    <p>
      Not every team did this, but my team did, and it was very convenient because months or years later, I could reconstruct the whole history of a module, including the reasoning for all 
      the <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">little hairs and bugfixes</a> that made little sense on first glance. Most of the time it was also possible to reproduce the bug with the steps contained, and even decide that 
      whatever fix was there could be deleted if needed (for example, as part of a refactor).
    </p>
    <p>
      Another thing we did that I haven't seen elsewhere is structure larger PRs so that they were readable commit-by-commit. No matter what order we had done our original changes in, 
      we would commit them in a logical sequence that made it clear what the PR was doing using a tool like <code>git add --interactive</code>. So for example if we were creating a new version 
      of a module that had a slightly different API and worked differently under-the-hood, our commits might look like so:
    </p>
    <!-- <dt-code block language="plaintext"> -->
      <pre class="l-middle">        <code class="language-plaintext">
1111111: Copy-paste old library code into new files
2222222: Make changes to code and function signatures in new files
3333333: Add feature flag and update call-sites
        </code>
    </pre>
    <!-- </dt-code> -->
    <p>
      This made changes extremely easy to review and doubled as a way for team members to learn how senior engineers thought.
    </p>
    <p>
      <b>3 things</b>. We had a beloved tradition<dt-fn>Some folks even got together and filmed a documentary about it over maker week, though I think they still haven't finished editing all the footage they took!</dt-fn> called 3 things where a person 
      would talk about 3 things that made them who they are. These used to be company-wide but at a certain scale, it gets weird to be
      vulnerable, so we stopped doing them (although my team reintroduced them internally).
    </p>
    <p>
      The prompt was intentionally vague - it didn't have to be the 3 biggest or deepest things, it could be any 3 things. Some people reached down deep and revealed formative experiences of heartfelt pieces of 
      themselves, while others talked about recent hobbies they were spending lots of time on or favorite books. I attended a bunch of these and felt that I really got to see beyond the "professional veil" to a
      more personal side of my coworkers, and I still regret not having participated.
    </p>
    <p>
      A common question for company cultures is whether the company is more like a "team" or a "family", and it's also a matter of opinion which one is better. During my time there, Figma was at least on the surface much more 
      like a family. Whereas companies like Netflix emphasize extraordinary candor, professionalism, and performance, Figma's culture emphasized empathy, mutual support, and growth, and 3 things more than anything else
      fostered empathy.
    </p>
    <p>
      Did it work for us? I think it did, and miraculously it did so without sacrificing performance: the folks I worked with are still some of the most brilliant and productive I've met, while being some of the kindest 
      (<a href="https://jamie-wong.com/">Jamie</a>, who is one of these people, calls them "humble wizards"). Yet it wasn't without tradeoffs: there were certainly times when I felt that we had over-emphasized support over candor 
      in communication, which made it hard to give or receive valuable feedback. But if I had to point at one reason why this culture worked so well for us, I think it was because the design tool space requires creativity,
      and you need an empathetic, supportive environment to foster that<dt-fn>Although maybe early Apple with "brilliant jerk" Steve Jobs is a counterexample. AFAIK we didn't have a brilliant jerk. So maybe the learning is: you can have either a brilliant jerk or a team of empathetic, supportive peers.</dt-fn>.
    </p>
  </dt-article>

  <dt-appendix>
  </dt-appendix>

  <script type="text/bibliography">
  </script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body);
    });
  </script>
</article>

</body></html>