{
  "version": 3,
  "sources": ["../shaders/addNoiseShader.glsl", "../shaders/advectionManualFilteringShader.glsl", "../shaders/advectionShader.glsl", "../shaders/baseVertexShader.glsl", "../shaders/buoyancyShader.glsl", "../shaders/circularVelocityFieldShader.glsl", "../shaders/clearShader.glsl", "../shaders/combustionShader.glsl", "../shaders/curlShader.glsl", "../shaders/debugFireShader.glsl", "../shaders/debugFloatShader.glsl", "../shaders/displayShader.glsl", "../shaders/displayFireShader.glsl", "../shaders/divergenceShader.glsl", "../shaders/particlesAdvectionShader.glsl", "../shaders/particlesRenderShader.glsl", "../shaders/particlesResetData.glsl", "../shaders/particlesResetLifespan.glsl", "../shaders/particlesStepLifespan.glsl", "../shaders/particlesVertexShader.glsl", "../shaders/pressureIterationShader.glsl", "../shaders/projectionShader.glsl", "../shaders/rowShader.glsl", "../shaders/splatShader.glsl", "../shaders/vorticityConfinementShader.glsl", "../demos.js", "../main.js"],
  "sourcesContent": ["/*\r\nBlends in procedural, time-evolving perlin noise to the given texture.\r\nhttp://www.science-and-fiction.org/rendering/noise.html#perlin_noise\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uTarget; // target texture\r\nuniform vec2 texelSize;\r\nuniform float blendLevel;\r\nuniform float time;\r\n\r\nfloat rand3D(in vec3 co){\r\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,144.7272))) * 43758.5453);\r\n}\r\nfloat simple_interpolate(in float a, in float b, in float x)\r\n{\r\n   return a + smoothstep(0.0,1.0,x) * (b-a);\r\n}\r\nfloat interpolatedNoise3D(in float x, in float y, in float z)\r\n{\r\n    float integer_x = x - fract(x);\r\n    float fractional_x = x - integer_x;\r\n\r\n    float integer_y = y - fract(y);\r\n    float fractional_y = y - integer_y;\r\n\r\n    float integer_z = z - fract(z);\r\n    float fractional_z = z - integer_z;\r\n\r\n    float v1 = rand3D(vec3(integer_x, integer_y, integer_z));\r\n    float v2 = rand3D(vec3(integer_x+1.0, integer_y, integer_z));\r\n    float v3 = rand3D(vec3(integer_x, integer_y+1.0, integer_z));\r\n    float v4 = rand3D(vec3(integer_x+1.0, integer_y +1.0, integer_z));\r\n\r\n    float v5 = rand3D(vec3(integer_x, integer_y, integer_z+1.0));\r\n    float v6 = rand3D(vec3(integer_x+1.0, integer_y, integer_z+1.0));\r\n    float v7 = rand3D(vec3(integer_x, integer_y+1.0, integer_z+1.0));\r\n    float v8 = rand3D(vec3(integer_x+1.0, integer_y +1.0, integer_z+1.0));\r\n\r\n    float i1 = simple_interpolate(v1,v5, fractional_z);\r\n    float i2 = simple_interpolate(v2,v6, fractional_z);\r\n    float i3 = simple_interpolate(v3,v7, fractional_z);\r\n    float i4 = simple_interpolate(v4,v8, fractional_z);\r\n\r\n    float ii1 = simple_interpolate(i1,i2,fractional_x);\r\n    float ii2 = simple_interpolate(i3,i4,fractional_x);\r\n\r\n    return simple_interpolate(ii1 , ii2 , fractional_y);\r\n}\r\nfloat Noise3D(in vec3 coord, in float wavelength)\r\n{\r\n   return interpolatedNoise3D(coord.x/wavelength, coord.y/wavelength, coord.z/wavelength);\r\n}\r\nvoid main() {\r\n    vec3 st = vec3(vUv, fract(time) * 0.7);\r\n    float L = texelSize.x;\r\n    float noise = 0.25 * (Noise3D(st, L) + Noise3D(st, L * 2.) + Noise3D(st, L * 3.) + Noise3D(st, L * 4.));\r\n    // float noise = Noise3D(st, L);\r\n    float base = texture2D(uTarget, vUv).x;\r\n    base += blendLevel * (noise - base);\r\n    gl_FragColor = vec4(base, base, base, 1.0);\r\n}\r\n", "/*\r\nAdvect a source field through the given velocity field with a manual interpolation function.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uVelocity; // velocity texture.\r\nuniform sampler2D uSource; // source field texture (scalar or velocity field)\r\nuniform vec2 texelSize;\r\nuniform vec2 dyeTexelSize;\r\nuniform float dt;\r\nuniform float dissipation;\r\n\r\n/* bilinear interpolation function.\r\n@param sampler2D sam - Texture to do the interpolation.\r\n@param vec2 uv - uv coords.\r\n@param vec2 tsize - Texel (grid square) size.\r\n*/\r\nvec4 bilerp (in sampler2D sam, in vec2 uv, in vec2 tsize) {\r\n  vec2 st = uv / tsize - 0.5;\r\n\r\n  vec2 iuv = floor(st);\r\n  vec2 fuv = fract(st);\r\n\r\n  vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\r\n  vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\r\n  vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\r\n  vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\r\n\r\n  return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\r\n}\r\n\r\nvoid main () {\r\n  vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\r\n  gl_FragColor = dissipation * bilerp(uSource, coord, dyeTexelSize);\r\n  gl_FragColor.a = 1.0;\r\n}\r\n", "/*\r\nAdvect a source field through a velocity field, assuming built-in interpolation.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uVelocity;\r\nuniform sampler2D uSource;\r\nuniform vec2 texelSize;\r\nuniform float dt;\r\nuniform float dissipation;\r\n\r\nvoid main () {\r\n  vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\r\n  gl_FragColor = dissipation * texture2D(uSource, coord);\r\n  gl_FragColor.a = 1.0;\r\n}\r\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nattribute vec2 aPosition; // range from (-1.0, -1.0) to (1.0, 1.0)\r\nvarying vec2 vUv; // UV mapping (texture) coordinates.\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vT;\r\nvarying vec2 vB;\r\nuniform vec2 texelSize;\r\n\r\nvoid main () {\r\n  vUv = aPosition * 0.5 + 0.5; // range from (0.0, 0.0) to (1.0, 1.0)\r\n\r\n  // get the uv coordinates surrounding the current texel.\r\n  vL = vUv - vec2(texelSize.x, 0.0); // left texel.\r\n  vR = vUv + vec2(texelSize.x, 0.0); // right texel.\r\n  vT = vUv + vec2(0.0, texelSize.y); // top texel.\r\n  vB = vUv - vec2(0.0, texelSize.y); // bottom texel.\r\n  gl_Position = vec4(aPosition, 0.0, 1.0);\r\n}\r\n", "/*\r\nAdd impulse to a velocity field due to thermal buoyancy.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uVelocity;\r\nuniform sampler2D uTemperature;\r\nuniform vec2 texelSize;\r\nuniform float dt;\r\nuniform float buoyancy; // buoyancy parameter.\r\n\r\nvoid main () {\r\n  float dTemp = texture2D(uTemperature, vUv).x;\r\n  vec2 impulse = dt * buoyancy * dTemp * vec2(0.0, 1.0);\r\n  vec2 vel = texture2D(uVelocity, vUv).xy;\r\n  gl_FragColor = vec4(vel + impulse, 0.0, 1.0);\r\n}\r\n", "/*\nWrite vectors comprising a circular velocity field to a vector field texture.\n*/\n\nprecision highp float;\nprecision mediump sampler2D;\n\nuniform float uSpeedMultiplier;\nvarying vec2 vUv;\n\nvoid main () {\n  vec2 coord = vUv.xy * 2.0 - 1.0;\n  gl_FragColor.x = coord.y * uSpeedMultiplier;\n  gl_FragColor.y = -coord.x * uSpeedMultiplier;\n  gl_FragColor.a = 1.0;\n}\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uTexture;\r\nuniform float value;\r\n\r\nvoid main () {\r\n  gl_FragColor = value * texture2D(uTexture, vUv);\r\n}\r\n", "/*\r\nAdd temperature based on fuel, and apply cooling.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uFuel;\r\nuniform sampler2D uTemperature;\r\nuniform sampler2D uNoise;\r\nuniform vec2 texelSize;\r\nuniform float dt;\r\nuniform float burnTemperature;\r\nuniform float noiseBlending;\r\nuniform float cooling; // cooling coefficient.\r\n\r\nfloat fuelTemperature (float fuel) {\r\n  return fuel * burnTemperature;\r\n}\r\n\r\nvoid main () {\r\n  float temp = texture2D(uTemperature, vUv).x;\r\n  float fuel = texture2D(uFuel, vUv).x;\r\n  float noise = 2.*(texture2D(uNoise, vUv).x - 0.5); // zero-mean noise.\r\n  // fuel += noise * noiseBlending;\r\n  // cool existing temperature.\r\n  temp = max(0.0, temp - dt * cooling * pow(temp / burnTemperature, 4.0));\r\n  // add more heat based on fuel.\r\n  temp = max(temp, fuelTemperature(fuel));\r\n  gl_FragColor = vec4(temp, 0.0, 0.0, 1.0);\r\n}\r\n", "/*\r\nCompute the curl (vorticity) of a velocity field.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vT;\r\nvarying vec2 vB;\r\nuniform sampler2D uVelocity;\r\nuniform sampler2D uNoise;\r\nuniform float blendLevel;\r\n\r\nvoid main () {\r\n  float L = texture2D(uVelocity, vL).y;\r\n  float R = texture2D(uVelocity, vR).y;\r\n  float T = texture2D(uVelocity, vT).x;\r\n  float B = texture2D(uVelocity, vB).x;\r\n  float vorticity = (R - L) - (T - B);\r\n  float noise = 1000. * (texture2D(uNoise, vUv).x - 0.5); // scale 0-1 noise up to the right level.\r\n  vorticity += blendLevel * noise;\r\n  gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\r\n}\r\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uFuel;\r\nuniform sampler2D uTemperature;\r\nuniform float fuelScalar;\r\nuniform float temperatureScalar;\r\n\r\nvoid main () {\r\n  float temp = temperatureScalar * texture2D(uTemperature, vUv).x;\r\n  float fuel = fuelScalar * texture2D(uFuel, vUv).x;\r\n  gl_FragColor = vec4(temp, fuel, 0.0, 1.0);\r\n}\r\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uTexture;\r\nuniform float scalar;\r\n\r\nvoid main () {\r\n  float value = scalar * texture2D(uTexture, vUv).x;\r\n  gl_FragColor = vec4(value, value, value, 1.0);\r\n}\r\n", "/*\r\nDisplay a texture.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uTexture;\r\n\r\nvoid main () {\r\n  gl_FragColor = texture2D(uTexture, vUv);\r\n}\r\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uDensity;\r\nuniform sampler2D uTemperature;\r\nuniform sampler2D uFuel;\r\nuniform float burnTemperature;\r\n\r\n// Blackbody color palette. Handy for all kinds of things.\r\nvec3 blackbody(float t){\r\n  // t = tLow + (tHigh - tLow)*t;\r\n  t *= (3000./burnTemperature); // Temperature range. Otherwise hardcoded from 0K to 4000K.\r\n\r\n  // Planckian locus or black body locus approximated in CIE color space.\r\n  float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\r\n  float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\r\n\r\n  // Converting the chromacity coordinates to XYZ tristimulus color space.\r\n  float d = (2.*cx - 8.*cy + 4.);\r\n  vec3 XYZ = vec3(3.*cx/d, 2.*cy/d, 1. - (3.*cx + 2.*cy)/d);\r\n\r\n  // Converting XYZ color space to RGB: https://www.cs.rit.edu/~ncs/color/t_spectr.html\r\n  vec3 RGB = mat3(3.240479, -0.969256, 0.055648, -1.537150, 1.875992, -0.204043,\r\n                  -0.498535, 0.041556, 1.057311) * vec3(1./XYZ.y*XYZ.x, 1., 1./XYZ.y*XYZ.z);\r\n\r\n  // Apply Stefan\u2013Boltzmann's law to the RGB color\r\n  return max(RGB, 0.)*pow(t*0.0004, 4.);\r\n}\r\n\r\nvoid main () {\r\n  float temp = texture2D(uTemperature, vUv).x;\r\n  float fuel = texture2D(uFuel, vUv).x;\r\n  float visibility = (exp(10.*fuel)-exp(-10.*fuel))/(exp(10.*fuel)+exp(-10.*fuel));\r\n  // float visibility = 1.;\r\n  vec4 density = texture2D(uDensity, vUv);\r\n\r\n  gl_FragColor = vec4(visibility*blackbody(temp), 1.0);\r\n}\r\n", "/*\r\nComputes the divergence of a velocity field at the given point through finite differences.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vT;\r\nvarying vec2 vB;\r\nuniform sampler2D uVelocity;\r\n\r\nvec2 sampleVelocity (in vec2 uv) {\r\n  vec2 multiplier = vec2(1.0, 1.0);\r\n  if (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }\r\n  if (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }\r\n  if (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }\r\n  if (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }\r\n  return multiplier * texture2D(uVelocity, uv).xy;\r\n}\r\n\r\nvoid main () {\r\n  float L = sampleVelocity(vL).x;\r\n  float R = sampleVelocity(vR).x;\r\n  float T = sampleVelocity(vT).y;\r\n  float B = sampleVelocity(vB).y;\r\n  float div = 0.5 * (R - L + T - B);\r\n  gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\r\n}\r\n", "/*\r\nAdvect an array of particles through a velocity field, assuming built-in interpolation.\r\n*/\r\n\r\nprecision highp float;\r\nprecision highp sampler2D;\r\n\r\nvarying vec2 vUv; // for particles, each texel is a separate particle.\r\nuniform sampler2D uVelocity;\r\nuniform float uSpeedMultiplier;\r\nuniform float dt;\r\n// texture where each texel color -> particle position.\r\nuniform sampler2D particleData;\r\n\r\nvec2 getVelocity (vec2 p) {\r\n  return vec2(\r\n    p.y,\r\n    -p.x\r\n  );\r\n}\r\n\r\nvoid main () {\r\n  vec2 p = texture2D(particleData, vUv).xy; // particle position (clip space).\r\n  vec2 p2 = p + dt * uSpeedMultiplier * getVelocity(p);\r\n\r\n  gl_FragColor = vec4(p2, 0.0, 1.0);\r\n}\r\n", "/*\r\nRender particles from a particle array to a texture where each particle is the given color.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nuniform vec3 color;\r\n\r\nvoid main () {\r\n  gl_FragColor = vec4(color, 1.0);\r\n}\r\n", "/*\r\nReset the position + velocity of any particles that have reached the end of their lifespans.\r\nCall this shader before resetting their lifespans!\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv; // for particles, each texel is a separate particle.\r\nuniform vec2 initialPosition;\r\nuniform vec2 initialVelocity;\r\nuniform sampler2D particleData; // texture where each texel color -> (particle position, particle velocity).\r\nuniform sampler2D particleLifespans; // texture where each texel color -> (particle lifespan, 0...)\r\n\r\nvec2 random2(vec2 st){\r\n    st = vec2( dot(st,vec2(127.1,311.7)),\r\n              dot(st,vec2(269.5,183.3)) );\r\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\r\n}\r\nvoid main () {\r\n  float life = texture2D(particleLifespans, vUv).x;\r\n  // each particle ID --> some different perturbation of initial conditions.\r\n  vec2 perturbation = 0.05 * random2(vUv);\r\n\r\n  vec2 p = texture2D(particleData, vUv).xy; // particle position (clip space).\r\n  vec2 v = texture2D(particleData, vUv).zw; // particle velocity.\r\n  if (life <= 0.0) {\r\n    gl_FragColor = vec4(initialPosition + perturbation, initialVelocity + perturbation);\r\n  } else {\r\n    gl_FragColor = texture2D(particleData, vUv);\r\n  }\r\n}\r\n", "/*\r\nReset the lifespan of any particles that have reached the end of their lifespans.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv; // for particles, each texel is a separate particle.\r\nuniform float initialLifespan;\r\nuniform sampler2D particleLifespans; // texture where each texel color -> (particle lifespan, 0...)\r\n\r\nfloat rand (vec2 st) {\r\n  return fract(sin(dot(st.xy,\r\n                       vec2(12.9898,78.233)))*\r\n      43758.5453123);\r\n}\r\nvoid main () {\r\n  float life = texture2D(particleLifespans, vUv).x;\r\n  // each particle ID --> some different perturbation of initial conditions.\r\n  float perturbation = rand(vUv) * 0.1;\r\n  if (life <= 0.0) {\r\n    gl_FragColor = vec4(initialLifespan + perturbation * initialLifespan, 0., 0., 1.);\r\n  } else {\r\n    gl_FragColor = vec4(life, 0., 0., 1.);\r\n  }\r\n}\r\n", "/*\r\nReduce particle lifespans by dt.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv; // for particles, each texel is a separate particle.\r\nuniform float dt;\r\nuniform sampler2D particleLifespans; // texture where each texel color -> (particle lifespan, 0...)\r\n\r\nvoid main () {\r\n  float life = texture2D(particleLifespans, vUv).x;\r\n  gl_FragColor = vec4(life - dt, 0., 0., 1.);\r\n}\r\n", "/*\r\nTransform a particle array texture into an array of vertices to render.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nuniform sampler2D particleData;\r\nuniform float size;\r\nattribute vec2 particleUV;\r\nvarying vec2 vUv; // each texel maps to its own particle.\r\n\r\nvoid main () {\r\n  // Scale the coordinates by some factor so that the user doesn't see the\r\n  // boundaries of the box inside which we originally seeded particles.\r\n  vec2 p = texture2D(particleData, particleUV).xy * 1.5;\r\n  vUv = particleUV;\r\n  gl_PointSize = size;\r\n  gl_Position = vec4(p, 0.0, 1.0);\r\n}\r\n", "/*\r\nCompute a single Jacobi iteration to approximately solve the Poisson equation\r\nfor pressure.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vT;\r\nvarying vec2 vB;\r\nuniform sampler2D uPressure;\r\nuniform sampler2D uDivergence;\r\n\r\nvec2 boundary (in vec2 uv) {\r\n  uv = min(max(uv, 0.0), 1.0);\r\n  return uv;\r\n}\r\n\r\nvoid main () {\r\n  float L = texture2D(uPressure, boundary(vL)).x;\r\n  float R = texture2D(uPressure, boundary(vR)).x;\r\n  float T = texture2D(uPressure, boundary(vT)).x;\r\n  float B = texture2D(uPressure, boundary(vB)).x;\r\n  float divergence = texture2D(uDivergence, vUv).x;\r\n  float pressure = (L + R + B + T - divergence) * 0.25;\r\n  gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\r\n}\r\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vT;\r\nvarying vec2 vB;\r\nuniform sampler2D uPressure;\r\nuniform sampler2D uVelocity;\r\n\r\n/*\r\nClamp a vec2 to the range(0.0, 1.0).\r\n*/\r\nvec2 boundary (in vec2 uv) {\r\n  uv = min(max(uv, 0.0), 1.0);\r\n  return uv;\r\n}\r\n\r\nvoid main () {\r\n  float L = texture2D(uPressure, boundary(vL)).x;\r\n  float R = texture2D(uPressure, boundary(vR)).x;\r\n  float T = texture2D(uPressure, boundary(vT)).x;\r\n  float B = texture2D(uPressure, boundary(vB)).x;\r\n  vec2 velocity = texture2D(uVelocity, vUv).xy;\r\n\r\n  // subtract the pressure gradient as computed by finite differences.\r\n  velocity.xy -= vec2(R - L, T - B);\r\n  \r\n  gl_FragColor = vec4(velocity, 0.0, 1.0);\r\n}\r\n", "/*\r\nFill a texel row below the y-coordinate with noise in the target texture.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uTarget; // target texture to create the row\r\nuniform float y; // y-coordinate of the row (in grid coordinates).\r\nuniform bool useMax; // if TRUE, output is max rather than additive.\r\nuniform vec2 texelSize; // simulation grid width.\r\n\r\nfloat rand (vec2 st) {\r\n  return fract(sin(dot(st.xy,\r\n                       vec2(12.9898,78.233)))*\r\n      43758.5453123);\r\n}\r\n\r\nfloat noise(vec2 p, float freq){\r\n\tfloat unit = 256.*texelSize.x/freq;\r\n\tvec2 ij = floor(p/unit);\r\n\tvec2 xy = mod(p,unit)/unit;\r\n\txy = .5*(1.-cos(3.1415926535*xy));\r\n\tfloat a = rand((ij+vec2(0.,0.)));\r\n\tfloat b = rand((ij+vec2(1.,0.)));\r\n\tfloat c = rand((ij+vec2(0.,1.)));\r\n\tfloat d = rand((ij+vec2(1.,1.)));\r\n\tfloat x1 = mix(a, b, xy.x);\r\n\tfloat x2 = mix(c, d, xy.x);\r\n\treturn mix(x1, x2, xy.y);\r\n}\r\n\r\nvoid main () {\r\n  vec3 base = texture2D(uTarget, vUv).xyz;\r\n  vec3 noise = vec3(noise(vUv, 100.)/.9 + .1, 0.0, 0.0);\r\n  // vec3 noise = vec3(1., 0., 0.);\r\n  if (vUv.y < texelSize.y * y) {\r\n    if (useMax) {\r\n      gl_FragColor = vec4(max(base, noise), 1.0);\r\n    } else {\r\n      gl_FragColor = vec4(base + noise, 1.0);\r\n    }\r\n  } else {\r\n    gl_FragColor = vec4(base, 1.0);\r\n  }\r\n}\r\n", "/*\r\nGiven uniforms point, color, radius, uTarget, aspectRatio, create a gaussian splat\r\nat the point with the given color and radius in the target texture.\r\n*/\r\n\r\nprecision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D uTarget; // target texture to create the splat\r\nuniform float aspectRatio;\r\nuniform vec3 color; // color of the splat\r\nuniform vec2 point; // x, y point to create the splat\r\nuniform float radius; // radius of the splat\r\nuniform bool useMax; // if TRUE, output is max rather than additive.\r\n\r\nvoid main () {\r\n  vec2 p = vUv - point.xy;\r\n  p.x *= aspectRatio;\r\n  vec3 splat = exp(-dot(p, p) / radius) * color; // gaussian splat.\r\n  vec3 base = texture2D(uTarget, vUv).xyz;\r\n  if (useMax) {\r\n    gl_FragColor = vec4(max(base, splat), 1.0);\r\n  } else {\r\n    gl_FragColor = vec4(base + splat, 1.0);\r\n  }\r\n}\r\n", "precision highp float;\r\nprecision mediump sampler2D;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vL;\r\nvarying vec2 vR;\r\nvarying vec2 vT;\r\nvarying vec2 vB;\r\nuniform sampler2D uVelocity;\r\nuniform sampler2D uCurl;\r\nuniform float confinement; // vorticity confinement constant.\r\nuniform float dt;\r\n\r\nvoid main () {\r\n  float L = texture2D(uCurl, vL).x;\r\n  float R = texture2D(uCurl, vR).x;\r\n  float T = texture2D(uCurl, vT).x;\r\n  float B = texture2D(uCurl, vB).x;\r\n  float C = texture2D(uCurl, vUv).x;\r\n\r\n  vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\r\n  force /= length(force) + 0.0001;\r\n  force *= confinement * C;\r\n  force.y *= -1.0;\r\n\r\n  vec2 vel = texture2D(uVelocity, vUv).xy;\r\n  gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\r\n}\r\n", "import addNoiseShaderSource from \"./shaders/addNoiseShader.glsl\";\nimport advectionManualFilteringShaderSource from \"./shaders/advectionManualFilteringShader.glsl\";\nimport advectionShaderSource from \"./shaders/advectionShader.glsl\";\nimport baseVertexShaderSource from \"./shaders/baseVertexShader.glsl\";\nimport buoyancyShaderSource from \"./shaders/buoyancyShader.glsl\";\nimport circularVelocityFieldShaderSource from \"./shaders/circularVelocityFieldShader.glsl\"\nimport clearShaderSource from \"./shaders/clearShader.glsl\";\nimport combustionShaderSource from \"./shaders/combustionShader.glsl\";\nimport curlShaderSource from \"./shaders/curlShader.glsl\";\nimport debugFireShaderSource from \"./shaders/debugFireShader.glsl\";\nimport debugFloatShaderSource from \"./shaders/debugFloatShader.glsl\";\nimport displayShaderSource from \"./shaders/displayShader.glsl\";\nimport displayFireShaderSource from \"./shaders/displayFireShader.glsl\";\nimport divergenceShaderSource from \"./shaders/divergenceShader.glsl\";\nimport particlesAdvectionShaderSource from \"./shaders/particlesAdvectionShader.glsl\";\nimport particlesRenderShaderSource from \"./shaders/particlesRenderShader.glsl\";\nimport particlesResetDataShaderSource from \"./shaders/particlesResetData.glsl\";\nimport particlesResetLifespanShaderSource from \"./shaders/particlesResetLifespan.glsl\";\nimport particlesStepLifespanShaderSource from \"./shaders/particlesStepLifespan.glsl\";\nimport particlesVertexShaderSource from \"./shaders/particlesVertexShader.glsl\";\nimport pressureIterationShaderSource from \"./shaders/pressureIterationShader.glsl\";\nimport projectionShaderSource from \"./shaders/projectionShader.glsl\";\nimport rowShaderSource from \"./shaders/rowShader.glsl\";\nimport splatShaderSource from \"./shaders/splatShader.glsl\";\nimport vorticityConfinementShaderSource from \"./shaders/vorticityConfinementShader.glsl\";\n\n// Ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\nvar numberToFloat16 = (function() {\n\n  var floatView = new Float32Array(1);\n  var int32View = new Int32Array(floatView.buffer);\n\n  /* This method is faster than the OpenEXR implementation (very often\n   * used, eg. in Ogre), with the additional benefit of rounding, inspired\n   * by James Tursa?s half-precision code. */\n  return (val) => {\n\n    floatView[0] = val;\n    var x = int32View[0];\n\n    var bits = (x >> 16) & 0x8000; /* Get the sign */\n    var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\n    var e = (x >> 23) & 0xff; /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\n     * half, return signed zero. */\n    if (e < 103) {\n      return bits;\n    }\n\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n       * not Inf, so make sure we set one mantissa bit too. */\n      bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\n      return bits;\n    }\n\n    /* If exponent underflows but not too much, return a denormal */\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\n       * to 1, which is OK. */\n      bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n      return bits;\n    }\n\n    bits |= ((e - 112) << 10) | (m >> 1);\n    /* Extra rounding. An overflow will set mantissa to 0 and increment\n     * the exponent, which is OK. */\n    bits += m & 1;\n    return bits;\n  };\n\n}());\n\n// Ref: https://gist.github.com/mfirmin/456e1c6dcf7b0e1bda6e940add32adad\n// This function converts a Float16 stored as the bits of a Uint16 into a Javascript Number.\n// Adapted from: https://gist.github.com/martinkallman/5049614\n// input is a Uint16 (eg, new Uint16Array([value])[0])\nfunction float16ToNumber(input) {\n  // Create a 32 bit DataView to store the input\n  const arr = new ArrayBuffer(4);\n  const dv = new DataView(arr);\n\n  // Set the Float16 into the last 16 bits of the dataview\n  // So our dataView is [00xx]\n  dv.setUint16(2, input, false);\n\n  // Get all 32 bits as a 32 bit integer\n  // (JS bitwise operations are performed on 32 bit signed integers)\n  const asInt32 = dv.getInt32(0, false);\n\n  // All bits aside from the sign\n  let rest = asInt32 & 0x7fff;\n  // Sign bit\n  let sign = asInt32 & 0x8000;\n  // Exponent bits\n  const exponent = asInt32 & 0x7c00;\n\n  // Shift the non-sign bits into place for a 32 bit Float\n  rest <<= 13;\n  // Shift the sign bit into place for a 32 bit Float\n  sign <<= 16;\n\n  // Adjust bias\n  // https://en.wikipedia.org/wiki/Half-precision_floating-point_format#Exponent_encoding\n  rest += 0x38000000;\n  // Denormals-as-zero\n  rest = (exponent === 0 ? 0 : rest);\n  // Re-insert sign bit\n  rest |= sign;\n\n  // Set the adjusted float32 (stored as int32) back into the dataview\n  dv.setInt32(0, rest, false);\n\n  // Get it back out as a float32 (which js will convert to a Number)\n  const asFloat32 = dv.getFloat32(0, false);\n\n  return asFloat32;\n}\n\nfunction getWebGLContext (canvas) {\n  const params = {\n    alpha: false,\n    depth: false,\n    stencil: false,\n    antialias: false,\n  };\n\n  let gl = canvas.getContext('webgl2', params);\n  const isWebGL2 = !!gl;\n  if (!isWebGL2) {\n    gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);\n  }\n\n  let halfFloat;\n  let supportLinearFiltering;\n  if (isWebGL2) {\n    gl.getExtension('EXT_color_buffer_float');\n    supportLinearFiltering = gl.getExtension('OES_texture_float_linear');\n  } else {\n    halfFloat = gl.getExtension('OES_texture_half_float');\n    supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');\n  }\n\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n  const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;\n  const floatTexType = gl.FLOAT;\n  let formatRGBA16F;\n  let formatRGBA32F;\n  let formatRG16F;\n  let formatRG32F;\n  let formatR16F;\n  let formatR32F;\n\n  if (isWebGL2) {\n    formatRGBA16F = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);\n    formatRGBA32F = getSupportedFormat(gl, gl.RGBA32F, gl.RGBA, floatTexType);\n    formatRG16F = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);\n    formatRG32F = getSupportedFormat(gl, gl.RG32F, gl.RG, floatTexType);\n    formatR16F = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);\n    formatR32F = getSupportedFormat(gl, gl.R32F, gl.RED, floatTexType);\n  } else {\n    formatRGBA16F = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    formatRGBA32F = getSupportedFormat(gl, gl.RGBA, gl.RGBA, floatTexType);\n    formatRG16F = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    formatRG32F = getSupportedFormat(gl, gl.RGBA, gl.RGBA, floatTexType);\n    formatR16F = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);\n    formatR32F = getSupportedFormat(gl, gl.RGBA, gl.RGBA, floatTexType);\n  }\n\n  if (formatRGBA16F == null) {\n    console.log(isWebGL2 ? 'webgl2' : 'webgl', 'not supported');\n  } else {\n    console.log(isWebGL2 ? 'webgl2' : 'webgl', 'supported');\n  }\n\n  return {\n    gl,\n    ext: {\n      formatRGBA16F,\n      formatRGBA32F,\n      formatRG16F,\n      formatRG32F,\n      formatR16F,\n      formatR32F,\n      floatTexType,\n      halfFloatTexType,\n      supportLinearFiltering,\n    },\n  };\n}\n\nfunction getSupportedFormat (gl, internalFormat, format, type) {\n  if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {\n    switch (internalFormat) {\n      case gl.R16F:\n        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);\n      case gl.RG16F:\n        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);\n      default:\n        return null;\n    }\n  }\n\n  return {\n    internalFormat,\n    format,\n  };\n}\n\nfunction supportRenderTextureFormat (gl, internalFormat, format, type) {\n  let texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);\n\n  let fbo = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status != gl.FRAMEBUFFER_COMPLETE) {\n    return false;\n  }\n  return true;\n}\n\n/*\nCompiles a shader of the given type (either gl.VERTEX_SHADER or gl.FRAGMENT_SHADER) and source code (string).\nReturns the WebGL shader handler.\n*/\nfunction compileShader (gl, type, source) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw gl.getShaderInfoLog(shader);\n  }\n\n  return shader;\n}\n\nfunction pointerPrototype () {\n  this.id = -1;\n  this.x = 0;\n  this.y = 0;\n  this.dx = 0;\n  this.dy = 0;\n  this.down = false;\n  this.moved = false;\n  this.color = {\n    r: 0.10,\n    g: 0.04,\n    b: 0.12,\n  };\n}\n\n// Make an SVG diagram illustrating the vector field u(x, y) = (y, -x) via a grid where\n// each cell contains an arrow indicating the velocity of the cell coordinate.\nexport function makeVectorFieldGridDiagram(svg) {\n  const width = svg.width.baseVal.value;\n  const height = svg.height.baseVal.value;\n  const N = 16;\n  let res = \"\";\n\n  const cellWidth = width / N;\n  const cellHeight = height / N;\n  const dotRadius = 1.5;\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      const cx = cellWidth * (j + 0.5);\n      const cy = cellHeight * (i + 0.5);\n      // clip space coords\n      const clipX = ((j + 0.5) / N) * 2.0 - 1.0;\n      const clipY = ((i + 0.5) / N) * -2.0 + 1.0;\n      // velocity\n      const uClipX = clipY;\n      const uClipY = -clipX;\n      const arrowScale = 16;\n      // arrow end coords\n      const tipX = cx + uClipX*arrowScale;\n      const tipY = cy - uClipY*arrowScale; // subtract since pixel coords increase downwards\n      const triangleScale = 2.5;\n      // normalize velocity direction\n      const uLen = Math.sqrt(uClipX * uClipX + uClipY * uClipY);\n      const uNormX = uClipX / uLen;\n      const uNormY = uClipY / uLen;\n      // get triangle vertices by moving down arrow, then move along tangent\n      const aX = tipX - uNormX * triangleScale + uNormY * triangleScale;\n      const aY = tipY - (-uNormY) * triangleScale - (-uNormX) * triangleScale;\n      const bX = tipX - uNormX * triangleScale - uNormY * triangleScale;\n      const bY = tipY - (-uNormY) * triangleScale + (-uNormX) * triangleScale;\n\n      // grid dot\n      res += `<circle cx=\"${cx}\" cy=\"${cy}\" r=\"${dotRadius}\" fill=\"black\" stroke=\"none\" />`;\n      // velocity arrow\n      res += `<line x1=\"${cx}\" y1=\"${cy}\" x2=\"${tipX}\" y2=\"${tipY}\" stroke=\"rgba(195, 75, 232.5, 255)\" stroke-width=\"0.75\" />`;\n      res += `<polygon points=\"${tipX},${tipY} ${aX},${aY} ${bX},${bY}\" fill=\"rgba(195, 75, 232.5, 255)\" stroke=\"none\" />`\n    }\n  }\n\n  svg.innerHTML = res;\n}\n\nexport function makeVelocityFieldSimulation(canvas) {\n  /*\n  class GLProgram\n\n  Encapsulates a WebGL program with vertex and fragment shader.\n  */\n  class GLProgram {\n    constructor (vertexShader, fragmentShader) {\n      this.uniforms = {}; // contains location of uniforms indexed by variable name.\n      this.program = gl.createProgram(); // the WebGL program.\n\n      gl.attachShader(this.program, vertexShader);\n      gl.attachShader(this.program, fragmentShader);\n      gl.linkProgram(this.program);\n\n      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n        throw gl.getProgramInfoLog(this.program);\n      }\n\n      const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        const uniformName = gl.getActiveUniform(this.program, i).name;\n        this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n      }\n    }\n\n    bind () {\n      gl.useProgram(this.program);\n    }\n  }\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  const { gl, ext } = getWebGLContext(canvas);\n  let config = {\n    DYE_RESOLUTION: 1024,\n    DENSITY_DISSIPATION: 0.999,\n    PARTICLE_RESOLUTION: 32,\n    SIM_RESOLUTION: 1024,\n    SPLAT_RADIUS: 0.3,\n  };\n  let LAST_TEX_ID = 0;\n  let pointers = [new pointerPrototype()];\n\n  let simRes = getResolution(config.SIM_RESOLUTION);\n  let dyeRes = getResolution(config.DYE_RESOLUTION);\n  let particleRes = { width: config.PARTICLE_RESOLUTION, height: config.PARTICLE_RESOLUTION };\n\n  let simWidth = simRes.width;\n  let simHeight = simRes.height;\n  let dyeWidth = dyeRes.width;\n  let dyeHeight = dyeRes.height;\n  let particleResWidth = particleRes.width;\n  let particleResHeight = particleRes.height;\n\n  let density;\n  let velocity;\n  let particleData;\n\n  const shaders = {\n    advectionManualFilteringShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionManualFilteringShaderSource),\n    advectionShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionShaderSource),\n    baseVertexShader: compileShader(gl, gl.VERTEX_SHADER, baseVertexShaderSource),\n    circularVelocityFieldShader: compileShader(gl, gl.FRAGMENT_SHADER, circularVelocityFieldShaderSource),\n    displayShader: compileShader(gl, gl.FRAGMENT_SHADER, displayShaderSource),\n    particlesAdvectionShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesAdvectionShaderSource),\n    particlesRenderShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesRenderShaderSource),\n    particlesVertexShader: compileShader(gl, gl.VERTEX_SHADER, particlesVertexShaderSource),\n    splatShader: compileShader(gl, gl.FRAGMENT_SHADER, splatShaderSource),\n  };\n\n  let advectionProgram =\n    new GLProgram(\n      shaders.baseVertexShader,\n      ext.supportLinearFiltering ? shaders.advectionShader : shaders.advectionManualFilteringShader\n    );\n  let displayProgram            = new GLProgram(shaders.baseVertexShader, shaders.displayShader);\n  let splatProgram              = new GLProgram(shaders.baseVertexShader, shaders.splatShader);\n  let velocityFieldProgram      = new GLProgram(shaders.baseVertexShader, shaders.circularVelocityFieldShader);\n\n  let particlesAdvectionProgram = new GLProgram(shaders.baseVertexShader, shaders.particlesAdvectionShader);\n  let particlesRenderProgram    = new GLProgram(shaders.particlesVertexShader, shaders.particlesRenderShader);\n\n  /*\n  Render quad to a specified framebuffer `destination`. If null, render to the default framebuffer.\n  */\n  const blit = (() => {\n    const quadVertexBuffer = gl.createBuffer();\n    const quadElementBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadElementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n\n    return (destination) => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n  })();\n  const blitParticles = (() => {\n    const vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    // Each particle is a vertex, the vertex attributes (2 floats)\n    // are the UV coords which point to texel containing particle data\n    // in the particleData texture\n    const particles = new Float32Array(particleResWidth * particleResHeight * 2);\n    for (let i = 0; i < particleResHeight; i++) {\n      for (let j = 0; j < particleResWidth; j++) {\n        particles[(i * particleResWidth + j) * 2] = (i + 0.5) / particleResHeight;\n        particles[(i * particleResWidth + j) * 2 + 1] = (j + 0.5) / particleResWidth;\n      }\n    }\n    gl.bufferData(gl.ARRAY_BUFFER, particles, gl.STATIC_DRAW);\n\n    return (destination) => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n      const particleUVLocation = gl.getAttribLocation(particlesRenderProgram.program, \"particleUV\");\n      gl.vertexAttribPointer(particleUVLocation, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(particleUVLocation);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n      gl.drawArrays(gl.POINTS, 0, particleResWidth * particleResHeight);\n    };\n  })();\n  // For debugging\n  const readParticle16 = (x, y, source) => {\n    const texType = ext.halfFloatTexType;\n    const rg = ext.formatRG16F;\n    // each particleData texel is 2 half floats (16 bits each)\n    const dest = new Uint16Array(2);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, source);\n    gl.readPixels(x, y, 1, 1, rg.format, texType, dest);\n    const particleX = float16ToNumber(new Uint16Array(dest.buffer, 0, 1));\n    const particleY = float16ToNumber(new Uint16Array(dest.buffer, 2, 1));\n    return {\n      x: particleX,\n      y: particleY\n    };\n  };\n  const readParticle32 = (x, y, source) => {\n    const texType = ext.floatTexType;\n    const rg = ext.formatRG16F;\n    // each particleData texel is 2 floats (32 bits each)\n    const dest = new Float32Array(2);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, source);\n    gl.readPixels(x, y, 1, 1, rg.format, texType, dest);\n    const particleX = dest[0];\n    const particleY = dest[1];\n    return {\n      x: particleX,\n      y: particleY\n    };\n  };\n\n  function getResolution (resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1) {\n      aspectRatio = 1.0 / aspectRatio;\n    }\n\n    let max = resolution * aspectRatio;\n    let min = resolution;\n\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight) {\n      return { width: max, height: min };\n    } else {\n      return { width: min, height: max };\n    }\n  }\n\n  function initFramebuffers() {\n    const texType = ext.halfFloatTexType;\n\n    density = createDoubleFBO(\n      dyeWidth,\n      dyeHeight,\n      ext.formatRGBA16F.internalFormat,\n      ext.formatRGBA16F.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    velocity = createFBO(\n      simWidth,\n      simHeight,\n      ext.formatRG16F.internalFormat,\n      ext.formatRG16F.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    particleData = createDoubleFBO(\n      particleResWidth,\n      particleResHeight,\n      ext.formatRG32F.internalFormat,\n      ext.formatRG32F.format,\n      ext.floatTexType,\n      gl.NEAREST\n    );\n\n    // Initialize particle data with random positions.\n    const particleDataInit = new Float32Array(particleResWidth * particleResHeight * 2);\n    for (let i = 0; i < particleResHeight; i++) {\n      for (let j = 0; j < particleResWidth; j++) {\n        particleDataInit[(i*particleResWidth + j)*2] = Math.random() * 2 - 1.0;\n        particleDataInit[(i*particleResWidth + j)*2 + 1] = Math.random() * 2 - 1.0;\n      }\n    }\n    gl.activeTexture(gl.TEXTURE0 + particleData.write.texId);\n    gl.texImage2D(gl.TEXTURE_2D, 0, ext.formatRG32F.internalFormat, particleResWidth, particleResHeight, 0, ext.formatRG32F.format, ext.floatTexType, particleDataInit);\n    particleData.swap();\n\n    // Initialize the fixed velocity field.\n    gl.viewport(0, 0, simWidth, simHeight);\n    velocityFieldProgram.bind();\n    gl.uniform1f(velocityFieldProgram.uniforms.uSpeedMultiplier, 0.05);\n    blit(velocity.fbo);\n  }\n\n  function createFBO (w, h, internalFormat, format, type, filter) {\n    const texId = LAST_TEX_ID++;\n    gl.activeTexture(gl.TEXTURE0 + texId);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    return {\n      texture,\n      fbo,\n      texId,\n    };\n  }\n\n  function createDoubleFBO (w, h, internalFormat, format, type, filter) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, filter);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, filter);\n\n    return {\n      get read () {\n        return fbo1;\n      },\n      get write () {\n        return fbo2;\n      },\n      swap () {\n        let temp = fbo1;\n        fbo1 = fbo2;\n        fbo2 = temp;\n      },\n    };\n  }\n\n  function update () {\n    resizeCanvas();\n    input();\n    step(0.016);\n    render();\n    requestAnimationFrame(update);\n  }\n\n  function input () {\n    for (let i = 0; i < pointers.length; i++) {\n      const pointer = pointers[i];\n      if (pointer.moved) {\n        splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);\n        pointer.moved = false;\n      }\n    }\n  }\n\n  function resizeCanvas () {\n    if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {\n      canvas.width = canvas.clientWidth;\n      canvas.height = canvas.clientHeight;\n      initFramebuffers();\n    }\n  }\n\n  function render () {\n    let width = gl.drawingBufferWidth;\n    let height = gl.drawingBufferHeight;\n\n    gl.viewport(0, 0, width, height);\n\n    displayProgram.bind();\n    gl.uniform1i(displayProgram.uniforms.uTexture, density.read.texId);\n    blit(null);\n\n    particlesRenderProgram.bind();\n    gl.uniform1i(particlesRenderProgram.uniforms.particleData, particleData.read.texId);\n    gl.uniform1f(particlesRenderProgram.uniforms.size, 2.0);\n    gl.uniform2f(particlesRenderProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform3f(particlesRenderProgram.uniforms.color, 1.0, 1.0, 1.0);\n    blitParticles(null);\n  }\n\n  function splat (x, y, dx, dy, color) {\n    gl.viewport(0, 0, simWidth, simHeight);\n    splatProgram.bind();\n\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);\n    gl.uniform1i(splatProgram.uniforms.uTarget, density.read.texId);\n    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(density.write.fbo);\n    density.swap();\n  }\n\n  /*\n  Update the programs by delta time.\n  */\n let stepNumber = 0;\n  function step (dt) {\n    stepNumber++;\n    gl.viewport(0, 0, simWidth, simHeight);\n\n    // Advect density (color) through the velocity field.\n    advectionProgram.bind();\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    // Unlike the fire demo program, don't scale velocity field by texel size.\n    // Instead, scale by 0.5 so that velocity is in clip space units per sec,\n    // not UV-space units per sec\n    gl.uniform2f(advectionProgram.uniforms.texelSize, 0.5, 0.5);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 0.5, 0.5);\n    }\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, density.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(density.write.fbo);\n    density.swap();\n\n    // Advect particles through the velocity field.\n    particlesAdvectionProgram.bind();\n    gl.viewport(0, 0, particleResWidth, particleResHeight);\n    gl.uniform1i(particlesAdvectionProgram.uniforms.uVelocity, velocity.texId);\n    // Not sure why, but particle velocity multiplier needs to be 2x dye velocity\n    gl.uniform1f(particlesAdvectionProgram.uniforms.uSpeedMultiplier, 0.05);\n    gl.uniform1f(particlesAdvectionProgram.uniforms.dt, dt);\n    gl.uniform1i(particlesAdvectionProgram.uniforms.particleData, particleData.read.texId);\n    blit(particleData.write.fbo);\n    particleData.swap();\n  }\n\n  canvas.addEventListener('mousemove', (e) => {\n    pointers[0].moved = pointers[0].down;\n    pointers[0].dx = (e.offsetX - pointers[0].x) * 5.0;\n    pointers[0].dy = (e.offsetY - pointers[0].y) * 5.0;\n    pointers[0].x = e.offsetX;\n    pointers[0].y = e.offsetY;\n  });\n\n  canvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      let pointer = pointers[i];\n      pointer.moved = pointer.down;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointer.dx = (offsetX - pointer.x) * 8.0;\n      pointer.dy = (offsetY - pointer.y) * 8.0;\n      pointer.x = offsetX;\n      pointer.y = offsetY;\n    }\n  }, false);\n\n  canvas.addEventListener('mousedown', (e) => {\n    pointers[0].down = true;\n    e.preventDefault();\n  });\n\n  canvas.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      if (i >= pointers.length) {\n        pointers.push(new pointerPrototype());\n      }\n\n      pointers[i].id = touches[i].identifier;\n      pointers[i].down = true;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointers[i].x = offsetX;\n      pointers[i].y = offsetY;\n    }\n  });\n\n  window.addEventListener('mouseup', () => {\n    pointers[0].down = false;\n  });\n\n  window.addEventListener('touchend', (e) => {\n    const touches = e.changedTouches;\n    for (let i = 0; i < touches.length; i++)\n      for (let j = 0; j < pointers.length; j++)\n        if (touches[i].identifier == pointers[j].id)\n          pointers[j].down = false;\n  });\n\n  initFramebuffers();\n\n  update();\n}\n\nexport function makeVorticitySimulation(canvas) {\n  /*\n  class GLProgram\n\n  Encapsulates a WebGL program with vertex and fragment shader.\n  */\n  class GLProgram {\n    constructor (vertexShader, fragmentShader) {\n      this.uniforms = {}; // contains location of uniforms indexed by variable name.\n      this.program = gl.createProgram(); // the WebGL program.\n\n      gl.attachShader(this.program, vertexShader);\n      gl.attachShader(this.program, fragmentShader);\n      gl.linkProgram(this.program);\n\n      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n        throw gl.getProgramInfoLog(this.program);\n      }\n\n      const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        const uniformName = gl.getActiveUniform(this.program, i).name;\n        this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n      }\n    }\n\n    bind () {\n      gl.useProgram(this.program);\n    }\n  }\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  let config = {\n    BURN_TEMPERATURE: 1700,\n    CONFINEMENT: 15,\n    DISPLAY_MODE: 0,\n    DYE_RESOLUTION: 512,\n    DENSITY_DISSIPATION: 0.99,\n    NOISE_BLENDING: 0.01,\n    NOISE_VOLATILITY: 0.001,\n    PRESSURE_DISSIPATION: 0.8,\n    PRESSURE_ITERATIONS: 20,\n    SIM_RESOLUTION: 256,\n    SPLAT_RADIUS: 1.0,\n    VELOCITY_DISSIPATION: 0.98,\n  };\n  let LAST_TEX_ID = 0;\n  let pointers = [new pointerPrototype()];\n\n  let simWidth;\n  let simHeight;\n  let dyeWidth;\n  let dyeHeight;\n\n  let curl;\n  let density;\n  let divergence;\n  let noise;\n  let pressure;\n  let velocity;\n\n  let addNoiseProgram;\n  let advectionProgram;\n  let clearProgram;\n  let curlProgram;\n  let displayProgram;\n  let divergenceProgram;\n  let pressureIterationProgram;\n  let projectionProgram;\n  let splatProgram;\n  let vorticityConfinementProgram;\n\n  const { gl, ext } = getWebGLContext(canvas);\n\n  const shaders = {\n    addNoiseShader: compileShader(gl, gl.FRAGMENT_SHADER, addNoiseShaderSource),\n    advectionManualFilteringShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionManualFilteringShaderSource),\n    advectionShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionShaderSource),\n    baseVertexShader: compileShader(gl, gl.VERTEX_SHADER, baseVertexShaderSource),\n    clearShader: compileShader(gl, gl.FRAGMENT_SHADER, clearShaderSource),\n    curlShader: compileShader(gl, gl.FRAGMENT_SHADER, curlShaderSource),\n    displayShader: compileShader(gl, gl.FRAGMENT_SHADER, displayShaderSource),\n    divergenceShader: compileShader(gl, gl.FRAGMENT_SHADER, divergenceShaderSource),\n    pressureIterationShader: compileShader(gl, gl.FRAGMENT_SHADER, pressureIterationShaderSource),\n    projectionShader: compileShader(gl, gl.FRAGMENT_SHADER, projectionShaderSource),\n    splatShader: compileShader(gl, gl.FRAGMENT_SHADER, splatShaderSource),\n    vorticityConfinementShader: compileShader(gl, gl.FRAGMENT_SHADER, vorticityConfinementShaderSource),\n  };\n\n  /*\n  Render quad to a specified framebuffer `destination`. If null, render to the default framebuffer.\n  */\n  const blit = (() => {\n    const quadVertexBuffer = gl.createBuffer();\n    const quadElementBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadElementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n\n    return (destination) => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n  })();\n\n  function getResolution (resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1) {\n      aspectRatio = 1.0 / aspectRatio;\n    }\n\n    let max = resolution * aspectRatio;\n    let min = resolution;\n\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight) {\n      return { width: max, height: min };\n    } else {\n      return { width: min, height: max };\n    }\n  }\n\n  function initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n\n    simWidth = simRes.width;\n    simHeight = simRes.height;\n    dyeWidth = dyeRes.width;\n    dyeHeight = dyeRes.height;\n\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA16F;\n    const rg = ext.formatRG16F;\n    const r = ext.formatR16F;\n\n    curl = createFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    density = createDoubleFBO(\n      dyeWidth,\n      dyeHeight,\n      rgba.internalFormat,\n      rgba.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    divergence = createFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    noise = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    pressure = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    velocity = createDoubleFBO(\n      simWidth,\n      simHeight,\n      rg.internalFormat,\n      rg.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n  }\n\n  function createFBO (w, h, internalFormat, format, type, filter) {\n    const texId = LAST_TEX_ID++;\n    gl.activeTexture(gl.TEXTURE0 + texId);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    return {\n      texture,\n      fbo,\n      texId,\n    };\n  }\n\n  function createDoubleFBO (w, h, internalFormat, format, type, filter) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, filter);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, filter);\n\n    return {\n      get read () {\n        return fbo1;\n      },\n      get write () {\n        return fbo2;\n      },\n      swap () {\n        let temp = fbo1;\n        fbo1 = fbo2;\n        fbo2 = temp;\n      },\n    };\n  }\n\n  function update () {\n    resizeCanvas();\n    input();\n    step(0.016);\n    render();\n    requestAnimationFrame(update);\n  }\n\n  function input () {\n    for (let i = 0; i < pointers.length; i++) {\n      const pointer = pointers[i];\n      if (pointer.moved) {\n        splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);\n        pointer.moved = false;\n      }\n    }\n  }\n\n  function resizeCanvas () {\n    if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {\n      canvas.width = canvas.clientWidth;\n      canvas.height = canvas.clientHeight;\n      initFramebuffers();\n    }\n  }\n\n  function render () {\n    let width = gl.drawingBufferWidth;\n    let height = gl.drawingBufferHeight;\n\n    gl.viewport(0, 0, width, height);\n\n    displayProgram.bind();\n    gl.uniform1i(displayProgram.uniforms.uTexture, density.read.texId);\n    blit(null);\n  }\n\n  function splat (x, y, dx, dy, color) {\n    gl.viewport(0, 0, simWidth, simHeight);\n    splatProgram.bind();\n    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.texId);\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);\n    gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    gl.uniform1i(splatProgram.uniforms.uTarget, density.read.texId);\n    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(density.write.fbo);\n    density.swap();\n  }\n\n  /*\n  Update the programs by delta time.\n  */\n  function step (dt) {\n    gl.viewport(0, 0, simWidth, simHeight);\n\n    // Advection step.\n    // Advect velocity through the velocity field.\n    advectionProgram.bind();\n    gl.uniform2f(advectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, velocity.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Do vorticity confinement on the velocity field.\n    // First, compute curl of the velocity.\n    curlProgram.bind();\n    gl.uniform2f(curlProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(curlProgram.uniforms.uNoise, noise.read.texId);\n    gl.uniform1f(curlProgram.uniforms.blendLevel, config.NOISE_BLENDING);\n    blit(curl.fbo);\n    // Confine vortices.\n    vorticityConfinementProgram.bind();\n    gl.uniform2f(vorticityConfinementProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(vorticityConfinementProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(vorticityConfinementProgram.uniforms.uCurl, curl.texId);\n    gl.uniform1f(vorticityConfinementProgram.uniforms.confinement, config.CONFINEMENT);\n    gl.uniform1f(vorticityConfinementProgram.uniforms.dt, dt);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Dissipate some pressure to give the illusion of an open box.\n    clearProgram.bind();\n    let pressureTexId = pressure.read.texId;\n    gl.activeTexture(gl.TEXTURE0 + pressureTexId);\n    gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);\n    gl.uniform1i(clearProgram.uniforms.uTexture, pressureTexId);\n    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION);\n    blit(pressure.write.fbo);\n    pressure.swap();\n\n    // Projection step.\n    gl.viewport(0, 0, simWidth, simHeight);\n    // Compute velocity divergence field.\n    divergenceProgram.bind();\n    gl.uniform2f(divergenceProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.texId);\n    blit(divergence.fbo);\n    // Solve for pressure field with Jacobi iteration.\n    pressureIterationProgram.bind();\n    gl.uniform1i(pressureIterationProgram.uniforms.uPressure, pressureTexId);\n    gl.uniform2f(pressureIterationProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(pressureIterationProgram.uniforms.uDivergence, divergence.texId);\n\n    for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n      gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);\n      blit(pressure.write.fbo);\n      pressure.swap();\n    }\n    // Subtract pressure gradient from velocity field to project.\n    projectionProgram.bind();\n    gl.uniform2f(projectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(projectionProgram.uniforms.uPressure, pressure.read.texId);\n    gl.uniform1i(projectionProgram.uniforms.uVelocity, velocity.read.texId);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Advect density (color) through the velocity field.\n    advectionProgram.bind();\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / dyeWidth, 1.0 / dyeHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, density.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(density.write.fbo);\n    density.swap();\n    // Advect noise.\n    gl.uniform1i(advectionProgram.uniforms.uSource, noise.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, 1.0);\n    blit(noise.write.fbo);\n    noise.swap();\n\n    // Blend in some noise to the noise channel.\n    addNoiseProgram.bind();\n    gl.uniform2f(addNoiseProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1f(addNoiseProgram.uniforms.time, (new Date()).getTime() / 1.e4 % 1);\n    gl.uniform1i(addNoiseProgram.uniforms.uTarget, noise.read.texId);\n    gl.uniform1f(addNoiseProgram.uniforms.blendLevel, config.NOISE_VOLATILITY);\n    blit(noise.write.fbo);\n    noise.swap();\n  }\n\n  canvas.addEventListener('mousemove', (e) => {\n    pointers[0].moved = pointers[0].down;\n    pointers[0].dx = (e.offsetX - pointers[0].x) * 5.0;\n    pointers[0].dy = (e.offsetY - pointers[0].y) * 5.0;\n    pointers[0].x = e.offsetX;\n    pointers[0].y = e.offsetY;\n  });\n\n  canvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      let pointer = pointers[i];\n      pointer.moved = pointer.down;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointer.dx = (offsetX - pointer.x) * 8.0;\n      pointer.dy = (offsetY - pointer.y) * 8.0;\n      pointer.x = offsetX;\n      pointer.y = offsetY;\n    }\n  }, false);\n\n  canvas.addEventListener('mousedown', (e) => {\n    pointers[0].down = true;\n    e.preventDefault();\n  });\n\n  canvas.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      if (i >= pointers.length) {\n        pointers.push(new pointerPrototype());\n      }\n\n      pointers[i].id = touches[i].identifier;\n      pointers[i].down = true;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointers[i].x = offsetX;\n      pointers[i].y = offsetY;\n    }\n  });\n\n  window.addEventListener('mouseup', () => {\n    pointers[0].down = false;\n  });\n\n  window.addEventListener('touchend', (e) => {\n    const touches = e.changedTouches;\n    for (let i = 0; i < touches.length; i++)\n      for (let j = 0; j < pointers.length; j++)\n        if (touches[i].identifier == pointers[j].id)\n          pointers[j].down = false;\n  });\n\n  advectionProgram =\n    new GLProgram(\n      shaders.baseVertexShader,\n      ext.supportLinearFiltering ? shaders.advectionShader : shaders.advectionManualFilteringShader\n    );\n  addNoiseProgram           = new GLProgram(shaders.baseVertexShader, shaders.addNoiseShader);\n  clearProgram              = new GLProgram(shaders.baseVertexShader, shaders.clearShader);\n  curlProgram               = new GLProgram(shaders.baseVertexShader, shaders.curlShader);\n  displayProgram            = new GLProgram(shaders.baseVertexShader, shaders.displayShader);\n  divergenceProgram         = new GLProgram(shaders.baseVertexShader, shaders.divergenceShader);\n  pressureIterationProgram  = new GLProgram(shaders.baseVertexShader, shaders.pressureIterationShader);\n  projectionProgram         = new GLProgram(shaders.baseVertexShader, shaders.projectionShader);\n  splatProgram              = new GLProgram(shaders.baseVertexShader, shaders.splatShader);\n  vorticityConfinementProgram = new GLProgram(shaders.baseVertexShader, shaders.vorticityConfinementShader);\n\n  initFramebuffers();\n\n  // Initialize the noise channel.\n  addNoiseProgram.bind();\n  gl.uniform2f(addNoiseProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1f(addNoiseProgram.uniforms.time, (new Date()).getTime() / 1.e6 % 1);\n  gl.uniform1i(addNoiseProgram.uniforms.uTarget, noise.read.texId);\n  gl.uniform1f(addNoiseProgram.uniforms.blendLevel, 1.0);\n  blit(noise.write.fbo);\n  noise.swap();\n\n  update();\n}\n\nexport function makeSmokeSimulation(canvas) {\n  /*\n  class GLProgram\n\n  Encapsulates a WebGL program with vertex and fragment shader.\n  */\n  class GLProgram {\n    constructor (vertexShader, fragmentShader) {\n      this.uniforms = {}; // contains location of uniforms indexed by variable name.\n      this.program = gl.createProgram(); // the WebGL program.\n\n      gl.attachShader(this.program, vertexShader);\n      gl.attachShader(this.program, fragmentShader);\n      gl.linkProgram(this.program);\n\n      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n        throw gl.getProgramInfoLog(this.program);\n      }\n\n      const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        const uniformName = gl.getActiveUniform(this.program, i).name;\n        this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n      }\n    }\n\n    bind () {\n      gl.useProgram(this.program);\n    }\n  }\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  let config = {\n    BUOYANCY: 0.2,\n    BURN_TEMPERATURE: 1700,\n    CONFINEMENT: 5,\n    COOLING: 3000,\n    DISPLAY_MODE: 0,\n    DYE_RESOLUTION: 512,\n    FUEL_DISSIPATION: 0.92,\n    DENSITY_DISSIPATION: 0.999,\n    NOISE_BLENDING: 0.5,\n    NOISE_VOLATILITY: 0.1,\n    PRESSURE_DISSIPATION: 0.8,\n    PRESSURE_ITERATIONS: 20,\n    SIM_RESOLUTION: 256,\n    SPLAT_RADIUS: 0.7,\n    VELOCITY_DISSIPATION: 0.98,\n  };\n  let LAST_TEX_ID = 0;\n  let pointers = [new pointerPrototype()];\n  let fireSources = [];\n\n  let simWidth;\n  let simHeight;\n  let dyeWidth;\n  let dyeHeight;\n\n  let curl;\n  let density;\n  let divergence;\n  let fuel;\n  let noise;\n  let pressure;\n  let temperature;\n  let velocity;\n\n  let addNoiseProgram;\n  let advectionProgram;\n  let buoyancyProgram;\n  let clearProgram;\n  let combustionProgram;\n  let curlProgram;\n  let displayProgram;\n  let divergenceProgram;\n  let pressureIterationProgram;\n  let projectionProgram;\n  let splatProgram;\n  let vorticityConfinementProgram;\n\n  const { gl, ext } = getWebGLContext(canvas);\n\n  const shaders = {\n    addNoiseShader: compileShader(gl, gl.FRAGMENT_SHADER, addNoiseShaderSource),\n    advectionManualFilteringShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionManualFilteringShaderSource),\n    advectionShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionShaderSource),\n    baseVertexShader: compileShader(gl, gl.VERTEX_SHADER, baseVertexShaderSource),\n    buoyancyShader: compileShader(gl, gl.FRAGMENT_SHADER, buoyancyShaderSource),\n    clearShader: compileShader(gl, gl.FRAGMENT_SHADER, clearShaderSource),\n    combustionShader: compileShader(gl, gl.FRAGMENT_SHADER, combustionShaderSource),\n    curlShader: compileShader(gl, gl.FRAGMENT_SHADER, curlShaderSource),\n    displayShader: compileShader(gl, gl.FRAGMENT_SHADER, displayShaderSource),\n    displayFireShader: compileShader(gl, gl.FRAGMENT_SHADER, displayFireShaderSource),\n    divergenceShader: compileShader(gl, gl.FRAGMENT_SHADER, divergenceShaderSource),\n    pressureIterationShader: compileShader(gl, gl.FRAGMENT_SHADER, pressureIterationShaderSource),\n    projectionShader: compileShader(gl, gl.FRAGMENT_SHADER, projectionShaderSource),\n    splatShader: compileShader(gl, gl.FRAGMENT_SHADER, splatShaderSource),\n    vorticityConfinementShader: compileShader(gl, gl.FRAGMENT_SHADER, vorticityConfinementShaderSource),\n  };\n\n  /*\n  Render quad to a specified framebuffer `destination`. If null, render to the default framebuffer.\n  */\n  const blit = (() => {\n    const quadVertexBuffer = gl.createBuffer();\n    const quadElementBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadElementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n\n    return (destination) => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n  })();\n\n  function getResolution (resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1) {\n      aspectRatio = 1.0 / aspectRatio;\n    }\n\n    let max = resolution * aspectRatio;\n    let min = resolution;\n\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight) {\n      return { width: max, height: min };\n    } else {\n      return { width: min, height: max };\n    }\n  }\n\n  function initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n\n    simWidth = simRes.width;\n    simHeight = simRes.height;\n    dyeWidth = dyeRes.width;\n    dyeHeight = dyeRes.height;\n\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA16F;\n    const rg = ext.formatRG16F;\n    const r = ext.formatR16F;\n\n    curl = createFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    density = createDoubleFBO(\n      dyeWidth,\n      dyeHeight,\n      rgba.internalFormat,\n      rgba.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    divergence = createFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    fuel = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    noise = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    pressure = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    temperature = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    velocity = createDoubleFBO(\n      simWidth,\n      simHeight,\n      rg.internalFormat,\n      rg.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n  }\n\n  function createFBO (w, h, internalFormat, format, type, filter) {\n    const texId = LAST_TEX_ID++;\n    gl.activeTexture(gl.TEXTURE0 + texId);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    return {\n      texture,\n      fbo,\n      texId,\n    };\n  }\n\n  function createDoubleFBO (w, h, internalFormat, format, type, filter) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, filter);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, filter);\n\n    return {\n      get read () {\n        return fbo1;\n      },\n      get write () {\n        return fbo2;\n      },\n      swap () {\n        let temp = fbo1;\n        fbo1 = fbo2;\n        fbo2 = temp;\n      },\n    };\n  }\n\n  function update () {\n    resizeCanvas();\n    input();\n    step(0.016);\n    render();\n    requestAnimationFrame(update);\n  }\n\n  function input () {\n    for (let i = 0; i < pointers.length; i++) {\n      const pointer = pointers[i];\n      if (pointer.moved) {\n        splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);\n        pointer.moved = false;\n      }\n    }\n  }\n\n  function resizeCanvas () {\n    if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {\n      canvas.width = canvas.clientWidth;\n      canvas.height = canvas.clientHeight;\n      initFramebuffers();\n    }\n  }\n\n  function render () {\n    let width = gl.drawingBufferWidth;\n    let height = gl.drawingBufferHeight;\n\n    gl.viewport(0, 0, width, height);\n\n    displayProgram.bind();\n    gl.uniform1i(displayProgram.uniforms.uTexture, density.read.texId);\n    blit(null);\n  }\n\n  function splat (x, y, dx, dy, color) {\n    gl.viewport(0, 0, simWidth, simHeight);\n    splatProgram.bind();\n    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.texId);\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);\n    gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    gl.uniform1i(splatProgram.uniforms.uTarget, fuel.read.texId);\n    gl.uniform3f(splatProgram.uniforms.color, 1.0, 0.0, 0.0);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, true);\n    blit(fuel.write.fbo);\n    fuel.swap();\n\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    gl.uniform1i(splatProgram.uniforms.uTarget, density.read.texId);\n    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(density.write.fbo);\n    density.swap();\n  }\n\n  /*\n  Update the programs by delta time.\n  */\n  function step (dt) {\n    gl.viewport(0, 0, simWidth, simHeight);\n\n    // Add fuel from particles to the *read* buffer.\n    fireSources.forEach(fireSource => {\n      fireSource.renderParticles(simWidth, simHeight, fuel.read.fbo, { r: 1.0, g: 0., b: 0. });\n    });\n\n    // Combustion step.\n    // Burn fuel and cool temperature.\n    combustionProgram.bind();\n    gl.uniform2f(combustionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(combustionProgram.uniforms.uFuel, fuel.read.texId);\n    gl.uniform1i(combustionProgram.uniforms.uTemperature, temperature.read.texId);\n    gl.uniform1i(combustionProgram.uniforms.uNoise, noise.read.texId);\n    gl.uniform1f(combustionProgram.uniforms.noiseBlending, config.NOISE_BLENDING);\n    gl.uniform1f(combustionProgram.uniforms.burnTemperature, config.BURN_TEMPERATURE);\n    gl.uniform1f(combustionProgram.uniforms.cooling, config.COOLING);\n    gl.uniform1f(combustionProgram.uniforms.dt, dt);\n    blit(temperature.write.fbo);\n    temperature.swap();\n\n    // Advection step.\n    // Advect velocity through the velocity field.\n    advectionProgram.bind();\n    gl.uniform2f(advectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, velocity.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Do vorticity confinement on the velocity field.\n    // First, compute curl of the velocity.\n    curlProgram.bind();\n    gl.uniform2f(curlProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(curlProgram.uniforms.uNoise, noise.read.texId);\n    gl.uniform1f(curlProgram.uniforms.blendLevel, config.NOISE_BLENDING);\n    blit(curl.fbo);\n    // Confine vortices.\n    vorticityConfinementProgram.bind();\n    gl.uniform2f(vorticityConfinementProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(vorticityConfinementProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(vorticityConfinementProgram.uniforms.uCurl, curl.texId);\n    gl.uniform1f(vorticityConfinementProgram.uniforms.confinement, config.CONFINEMENT);\n    gl.uniform1f(vorticityConfinementProgram.uniforms.dt, dt);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Add thermal buoyancy to velocity.\n    buoyancyProgram.bind();\n    gl.uniform2f(buoyancyProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(buoyancyProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(buoyancyProgram.uniforms.uTemperature, temperature.read.texId);\n    gl.uniform1f(buoyancyProgram.uniforms.buoyancy, config.BUOYANCY);\n    gl.uniform1f(buoyancyProgram.uniforms.dt, dt);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Dissipate some pressure to give the illusion of an open box.\n    clearProgram.bind();\n    let pressureTexId = pressure.read.texId;\n    gl.activeTexture(gl.TEXTURE0 + pressureTexId);\n    gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);\n    gl.uniform1i(clearProgram.uniforms.uTexture, pressureTexId);\n    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION);\n    blit(pressure.write.fbo);\n    pressure.swap();\n\n    // Projection step.\n    gl.viewport(0, 0, simWidth, simHeight);\n    // Compute velocity divergence field.\n    divergenceProgram.bind();\n    gl.uniform2f(divergenceProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.texId);\n    blit(divergence.fbo);\n    // Solve for pressure field with Jacobi iteration.\n    pressureIterationProgram.bind();\n    gl.uniform1i(pressureIterationProgram.uniforms.uPressure, pressureTexId);\n    gl.uniform2f(pressureIterationProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(pressureIterationProgram.uniforms.uDivergence, divergence.texId);\n\n    for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n      gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);\n      blit(pressure.write.fbo);\n      pressure.swap();\n    }\n    // Subtract pressure gradient from velocity field to project.\n    projectionProgram.bind();\n    gl.uniform2f(projectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(projectionProgram.uniforms.uPressure, pressure.read.texId);\n    gl.uniform1i(projectionProgram.uniforms.uVelocity, velocity.read.texId);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Advect density (color) through the velocity field.\n    advectionProgram.bind();\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / dyeWidth, 1.0 / dyeHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, density.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(density.write.fbo);\n    density.swap();\n    // Advect temperature.\n    gl.viewport(0, 0, simWidth, simHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uSource, temperature.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, 1.0);\n    blit(temperature.write.fbo);\n    temperature.swap();\n    // Advect fuel.\n    gl.uniform1i(advectionProgram.uniforms.uSource, fuel.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.FUEL_DISSIPATION);\n    blit(fuel.write.fbo);\n    fuel.swap();\n    // Advect noise.\n    gl.uniform1i(advectionProgram.uniforms.uSource, noise.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, 1.0);\n    blit(noise.write.fbo);\n    noise.swap();\n\n    // Blend in some noise to the noise channel.\n    addNoiseProgram.bind();\n    gl.uniform2f(addNoiseProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1f(addNoiseProgram.uniforms.time, (new Date()).getTime() / 1.e4 % 1);\n    gl.uniform1i(addNoiseProgram.uniforms.uTarget, noise.read.texId);\n    gl.uniform1f(addNoiseProgram.uniforms.blendLevel, config.NOISE_VOLATILITY);\n    blit(noise.write.fbo);\n    noise.swap();\n\n    fireSources.forEach(fireSource => fireSource.step(dt));\n  }\n\n  canvas.addEventListener('mousemove', (e) => {\n    pointers[0].moved = pointers[0].down;\n    pointers[0].dx = (e.offsetX - pointers[0].x) * 5.0;\n    pointers[0].dy = (e.offsetY - pointers[0].y) * 5.0;\n    pointers[0].x = e.offsetX;\n    pointers[0].y = e.offsetY;\n  });\n\n  canvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      let pointer = pointers[i];\n      pointer.moved = pointer.down;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointer.dx = (offsetX - pointer.x) * 8.0;\n      pointer.dy = (offsetY - pointer.y) * 8.0;\n      pointer.x = offsetX;\n      pointer.y = offsetY;\n    }\n  }, false);\n\n  canvas.addEventListener('mousedown', (e) => {\n    pointers[0].down = true;\n    pointers[0].color = {\n      r: 0.5,\n      g: 0.5,\n      b: 0.5\n    };\n    e.preventDefault();\n  });\n\n  canvas.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      if (i >= pointers.length) {\n        pointers.push(new pointerPrototype());\n      }\n\n      pointers[i].id = touches[i].identifier;\n      pointers[i].down = true;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointers[i].x = offsetX;\n      pointers[i].y = offsetY;\n      pointers[i].color = {\n        r: 0.5,\n        g: 0.5,\n        b: 0.5\n      };\n    }\n  });\n\n  window.addEventListener('mouseup', () => {\n    pointers[0].down = false;\n  });\n\n  window.addEventListener('touchend', (e) => {\n    const touches = e.changedTouches;\n    for (let i = 0; i < touches.length; i++)\n      for (let j = 0; j < pointers.length; j++)\n        if (touches[i].identifier == pointers[j].id)\n          pointers[j].down = false;\n  });\n\n  advectionProgram =\n    new GLProgram(\n      shaders.baseVertexShader,\n      ext.supportLinearFiltering ? shaders.advectionShader : shaders.advectionManualFilteringShader\n    );\n  addNoiseProgram           = new GLProgram(shaders.baseVertexShader, shaders.addNoiseShader);\n  buoyancyProgram           = new GLProgram(shaders.baseVertexShader, shaders.buoyancyShader);\n  clearProgram              = new GLProgram(shaders.baseVertexShader, shaders.clearShader);\n  combustionProgram         = new GLProgram(shaders.baseVertexShader, shaders.combustionShader);\n  curlProgram               = new GLProgram(shaders.baseVertexShader, shaders.curlShader);\n  displayProgram            = new GLProgram(shaders.baseVertexShader, shaders.displayShader);\n  divergenceProgram         = new GLProgram(shaders.baseVertexShader, shaders.divergenceShader);\n  pressureIterationProgram  = new GLProgram(shaders.baseVertexShader, shaders.pressureIterationShader);\n  projectionProgram         = new GLProgram(shaders.baseVertexShader, shaders.projectionShader);\n  splatProgram              = new GLProgram(shaders.baseVertexShader, shaders.splatShader);\n  vorticityConfinementProgram = new GLProgram(shaders.baseVertexShader, shaders.vorticityConfinementShader);\n\n  initFramebuffers();\n\n  // Initialize the noise channel.\n  addNoiseProgram.bind();\n  gl.uniform2f(addNoiseProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1f(addNoiseProgram.uniforms.time, (new Date()).getTime() / 1.e6 % 1);\n  gl.uniform1i(addNoiseProgram.uniforms.uTarget, noise.read.texId);\n  gl.uniform1f(addNoiseProgram.uniforms.blendLevel, 1.0);\n  blit(noise.write.fbo);\n  noise.swap();\n\n  update();\n}\n\nexport function makeFireSimulation(canvas) {\n  /*\n  class GLProgram\n\n  Encapsulates a WebGL program with vertex and fragment shader.\n  */\n  class GLProgram {\n    constructor (vertexShader, fragmentShader) {\n      this.uniforms = {}; // contains location of uniforms indexed by variable name.\n      this.program = gl.createProgram(); // the WebGL program.\n\n      gl.attachShader(this.program, vertexShader);\n      gl.attachShader(this.program, fragmentShader);\n      gl.linkProgram(this.program);\n\n      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n        throw gl.getProgramInfoLog(this.program);\n      }\n\n      const uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n      for (let i = 0; i < uniformCount; i++) {\n        const uniformName = gl.getActiveUniform(this.program, i).name;\n        this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);\n      }\n    }\n\n    bind () {\n      gl.useProgram(this.program);\n    }\n  }\n  canvas.width = canvas.clientWidth;\n  canvas.height = canvas.clientHeight;\n  let config = {\n    BUOYANCY: 0.2,\n    BURN_TEMPERATURE: 1700,\n    CONFINEMENT: 15,\n    COOLING: 3000,\n    DISPLAY_MODE: 0,\n    DYE_RESOLUTION: 512,\n    FUEL_DISSIPATION: 0.92,\n    DENSITY_DISSIPATION: 0.99,\n    NOISE_BLENDING: 0.5,\n    NOISE_VOLATILITY: 0.1,\n    PRESSURE_DISSIPATION: 0.8,\n    PRESSURE_ITERATIONS: 20,\n    SIM_RESOLUTION: 256,\n    SPLAT_RADIUS: 1.5,\n    VELOCITY_DISSIPATION: 0.98,\n  };\n  let DISPLAY_MODES = [\"Normal\", \"DebugFire\", \"DebugTemperature\", \"DebugFuel\", \"DebugPressure\", \"DebugDensity\", \"DebugNoise\"];\n  let LAST_TEX_ID = 0;\n  let pointers = [new pointerPrototype()];\n  let fireSources = [];\n\n  let simWidth;\n  let simHeight;\n  let dyeWidth;\n  let dyeHeight;\n\n  let curl;\n  let density;\n  let divergence;\n  let fuel;\n  let noise;\n  let pressure;\n  let temperature;\n  let velocity;\n\n  let addNoiseProgram;\n  let advectionProgram;\n  let buoyancyProgram;\n  let clearProgram;\n  let combustionProgram;\n  let curlProgram;\n  let debugFireProgram;\n  let debugFloatProgram;\n  let displayProgram;\n  let displayFireProgram;\n  let divergenceProgram;\n  let particlesAdvectionProgram;\n  let particlesRenderProgram;\n  let particlesResetDataProgram;\n  let particlesResetLifespanProgram;\n  let particlesStepLifespanProgram;\n  let pressureIterationProgram;\n  let projectionProgram;\n  let rowProgram;\n  let splatProgram;\n  let vorticityConfinementProgram;\n\n  const { gl, ext } = getWebGLContext(canvas);\n\n  const shaders = {\n    addNoiseShader: compileShader(gl, gl.FRAGMENT_SHADER, addNoiseShaderSource),\n    advectionManualFilteringShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionManualFilteringShaderSource),\n    advectionShader: compileShader(gl, gl.FRAGMENT_SHADER, advectionShaderSource),\n    baseVertexShader: compileShader(gl, gl.VERTEX_SHADER, baseVertexShaderSource),\n    buoyancyShader: compileShader(gl, gl.FRAGMENT_SHADER, buoyancyShaderSource),\n    clearShader: compileShader(gl, gl.FRAGMENT_SHADER, clearShaderSource),\n    combustionShader: compileShader(gl, gl.FRAGMENT_SHADER, combustionShaderSource),\n    curlShader: compileShader(gl, gl.FRAGMENT_SHADER, curlShaderSource),\n    debugFireShader: compileShader(gl, gl.FRAGMENT_SHADER, debugFireShaderSource),\n    debugFloatShader: compileShader(gl, gl.FRAGMENT_SHADER, debugFloatShaderSource),\n    displayShader: compileShader(gl, gl.FRAGMENT_SHADER, displayShaderSource),\n    displayFireShader: compileShader(gl, gl.FRAGMENT_SHADER, displayFireShaderSource),\n    divergenceShader: compileShader(gl, gl.FRAGMENT_SHADER, divergenceShaderSource),\n    particlesAdvectionShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesAdvectionShaderSource),\n    particlesRenderShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesRenderShaderSource),\n    particlesResetDataShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesResetDataShaderSource),\n    particlesResetLifespanShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesResetLifespanShaderSource),\n    particlesStepLifespanShader: compileShader(gl, gl.FRAGMENT_SHADER, particlesStepLifespanShaderSource),\n    particlesVertexShader: compileShader(gl, gl.VERTEX_SHADER, particlesVertexShaderSource),\n    pressureIterationShader: compileShader(gl, gl.FRAGMENT_SHADER, pressureIterationShaderSource),\n    projectionShader: compileShader(gl, gl.FRAGMENT_SHADER, projectionShaderSource),\n    rowShader: compileShader(gl, gl.FRAGMENT_SHADER, rowShaderSource),\n    splatShader: compileShader(gl, gl.FRAGMENT_SHADER, splatShaderSource),\n    vorticityConfinementShader: compileShader(gl, gl.FRAGMENT_SHADER, vorticityConfinementShaderSource),\n  };\n\n  /*\n  Render quad to a specified framebuffer `destination`. If null, render to the default framebuffer.\n  */\n  const blit = (() => {\n    const quadVertexBuffer = gl.createBuffer();\n    const quadElementBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, quadElementBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);\n\n    return (destination) => {\n      gl.bindBuffer(gl.ARRAY_BUFFER, quadVertexBuffer);\n      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);\n      gl.enableVertexAttribArray(0);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, destination);\n      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    };\n  })();\n\n  function getResolution (resolution) {\n    let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;\n    if (aspectRatio < 1) {\n      aspectRatio = 1.0 / aspectRatio;\n    }\n\n    let max = resolution * aspectRatio;\n    let min = resolution;\n\n    if (gl.drawingBufferWidth > gl.drawingBufferHeight) {\n      return { width: max, height: min };\n    } else {\n      return { width: min, height: max };\n    }\n  }\n\n  function initFramebuffers() {\n    let simRes = getResolution(config.SIM_RESOLUTION);\n    let dyeRes = getResolution(config.DYE_RESOLUTION);\n\n    simWidth = simRes.width;\n    simHeight = simRes.height;\n    dyeWidth = dyeRes.width;\n    dyeHeight = dyeRes.height;\n\n    const texType = ext.halfFloatTexType;\n    const rgba = ext.formatRGBA16F;\n    const rg = ext.formatRG16F;\n    const r = ext.formatR16F;\n\n    curl = createFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    density = createDoubleFBO(\n      dyeWidth,\n      dyeHeight,\n      rgba.internalFormat,\n      rgba.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    divergence = createFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    fuel = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    noise = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    pressure = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      gl.NEAREST,\n    );\n    temperature = createDoubleFBO(\n      simWidth,\n      simHeight,\n      r.internalFormat,\n      r.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n    velocity = createDoubleFBO(\n      simWidth,\n      simHeight,\n      rg.internalFormat,\n      rg.format,\n      texType,\n      ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST,\n    );\n  }\n\n  function createFBO (w, h, internalFormat, format, type, filter) {\n    const texId = LAST_TEX_ID++;\n    gl.activeTexture(gl.TEXTURE0 + texId);\n    let texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);\n\n    let fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.viewport(0, 0, w, h);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    return {\n      texture,\n      fbo,\n      texId,\n    };\n  }\n\n  function createDoubleFBO (w, h, internalFormat, format, type, filter) {\n    let fbo1 = createFBO(w, h, internalFormat, format, type, filter);\n    let fbo2 = createFBO(w, h, internalFormat, format, type, filter);\n\n    return {\n      get read () {\n        return fbo1;\n      },\n      get write () {\n        return fbo2;\n      },\n      swap () {\n        let temp = fbo1;\n        fbo1 = fbo2;\n        fbo2 = temp;\n      },\n    };\n  }\n\n  function update () {\n    resizeCanvas();\n    input();\n    step(0.016);\n    render();\n    requestAnimationFrame(update);\n  }\n\n  function input () {\n    // bottom row fire\n    gl.viewport(0, 0, simWidth, simHeight);\n    rowProgram.bind();\n    gl.uniform2f(rowProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1f(rowProgram.uniforms.y, 10.0);\n    gl.uniform1i(rowProgram.uniforms.uTarget, fuel.read.texId);\n    gl.uniform1f(rowProgram.uniforms.useMax, true);\n    blit(fuel.write.fbo);\n    fuel.swap();\n\n    for (let i = 0; i < pointers.length; i++) {\n      const pointer = pointers[i];\n      if (pointer.down) {\n        splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);\n      }\n      if (pointer.moved) {\n        pointer.moved = false;\n        pointer.dx = 0;\n        pointer.dy = 0;\n      }\n    }\n  }\n\n  function resizeCanvas () {\n    if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {\n      canvas.width = canvas.clientWidth;\n      canvas.height = canvas.clientHeight;\n      initFramebuffers();\n    }\n  }\n\n  function render () {\n    let width = gl.drawingBufferWidth;\n    let height = gl.drawingBufferHeight;\n\n    gl.viewport(0, 0, width, height);\n\n    switch(DISPLAY_MODES[config.DISPLAY_MODE]) {\n      case \"Normal\": {\n        displayFireProgram.bind();\n        gl.uniform1i(displayFireProgram.uniforms.uDensity, density.read.texId);\n        gl.uniform1i(displayFireProgram.uniforms.uTemperature, temperature.read.texId);\n        gl.uniform1i(displayFireProgram.uniforms.uFuel, fuel.read.texId);\n        gl.uniform1f(displayFireProgram.uniforms.burnTemperature, config.BURN_TEMPERATURE);\n        blit(null);\n\n        // render particles from each emitter\n        fireSources.forEach(fireSource => {\n          fireSource.renderParticles(width, height, null, { r: 1.0, g: 1.0, b: 1.0 });\n        });\n        break;\n      }\n      case \"DebugFire\": {\n        debugFireProgram.bind();\n        gl.uniform1i(debugFireProgram.uniforms.uFuel, fuel.read.texId);\n        gl.uniform1i(debugFireProgram.uniforms.uTemperature, temperature.read.texId);\n        gl.uniform1f(debugFireProgram.uniforms.temperatureScalar, 0.001);\n        gl.uniform1f(debugFireProgram.uniforms.fuelScalar, 1.0);\n        blit(null);\n        break;\n      }\n      case \"DebugTemperature\": {\n        debugFloatProgram.bind();\n        gl.uniform1i(debugFloatProgram.uniforms.uTexture, temperature.read.texId);\n        gl.uniform1f(debugFloatProgram.uniforms.scalar, 0.001);\n        blit(null);\n        break;\n      }\n      case \"DebugFuel\": {\n        debugFloatProgram.bind();\n        gl.uniform1i(debugFloatProgram.uniforms.uTexture, fuel.read.texId);\n        gl.uniform1f(debugFloatProgram.uniforms.scalar, 1.0);\n        blit(null);\n        break;\n      }\n      case \"DebugPressure\": {\n        debugFloatProgram.bind();\n        gl.uniform1i(debugFloatProgram.uniforms.uTexture, pressure.read.texId);\n        gl.uniform1f(debugFloatProgram.uniforms.scalar, 1.0);\n        blit(null);\n        break;\n      }\n      case \"DebugNoise\": {\n        debugFloatProgram.bind();\n        gl.uniform1i(debugFloatProgram.uniforms.uTexture, noise.read.texId);\n        gl.uniform1f(debugFloatProgram.uniforms.scalar, 1.0);\n        blit(null);\n        break;\n      }\n      default: /* DebugDensity */ {\n        displayProgram.bind();\n        gl.uniform1i(displayProgram.uniforms.uTexture, density.read.texId);\n        blit(null);\n        break;\n      }\n    }\n  }\n\n  function splat (x, y, dx, dy, color) {\n    gl.viewport(0, 0, simWidth, simHeight);\n    splatProgram.bind();\n    gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.texId);\n    gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);\n    gl.uniform2f(splatProgram.uniforms.point, x / canvas.width, 1.0 - y / canvas.height);\n    gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    gl.uniform1i(splatProgram.uniforms.uTarget, fuel.read.texId);\n    gl.uniform3f(splatProgram.uniforms.color, 1.0, 0.0, 0.0);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, true);\n    blit(fuel.write.fbo);\n    fuel.swap();\n\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    gl.uniform1i(splatProgram.uniforms.uTarget, density.read.texId);\n    gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);\n    gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100.0);\n    gl.uniform1f(splatProgram.uniforms.useMax, false);\n    blit(density.write.fbo);\n    density.swap();\n  }\n\n  /*\n  Update the programs by delta time.\n  */\n  function step (dt) {\n    gl.viewport(0, 0, simWidth, simHeight);\n\n    // Add fuel from particles to the *read* buffer.\n    fireSources.forEach(fireSource => {\n      fireSource.renderParticles(simWidth, simHeight, fuel.read.fbo, { r: 1.0, g: 0., b: 0. });\n    });\n\n    // Combustion step.\n    // Burn fuel and cool temperature.\n    combustionProgram.bind();\n    gl.uniform2f(combustionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(combustionProgram.uniforms.uFuel, fuel.read.texId);\n    gl.uniform1i(combustionProgram.uniforms.uTemperature, temperature.read.texId);\n    gl.uniform1i(combustionProgram.uniforms.uNoise, noise.read.texId);\n    gl.uniform1f(combustionProgram.uniforms.noiseBlending, config.NOISE_BLENDING);\n    gl.uniform1f(combustionProgram.uniforms.burnTemperature, config.BURN_TEMPERATURE);\n    gl.uniform1f(combustionProgram.uniforms.cooling, config.COOLING);\n    gl.uniform1f(combustionProgram.uniforms.dt, dt);\n    blit(temperature.write.fbo);\n    temperature.swap();\n\n    // Advection step.\n    // Advect velocity through the velocity field.\n    advectionProgram.bind();\n    gl.uniform2f(advectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, velocity.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dt, dt);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Do vorticity confinement on the velocity field.\n    // First, compute curl of the velocity.\n    curlProgram.bind();\n    gl.uniform2f(curlProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(curlProgram.uniforms.uNoise, noise.read.texId);\n    gl.uniform1f(curlProgram.uniforms.blendLevel, config.NOISE_BLENDING);\n    blit(curl.fbo);\n    // Confine vortices.\n    vorticityConfinementProgram.bind();\n    gl.uniform2f(vorticityConfinementProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(vorticityConfinementProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(vorticityConfinementProgram.uniforms.uCurl, curl.texId);\n    gl.uniform1f(vorticityConfinementProgram.uniforms.confinement, config.CONFINEMENT);\n    gl.uniform1f(vorticityConfinementProgram.uniforms.dt, dt);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Add thermal buoyancy to velocity.\n    buoyancyProgram.bind();\n    gl.uniform2f(buoyancyProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(buoyancyProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(buoyancyProgram.uniforms.uTemperature, temperature.read.texId);\n    gl.uniform1f(buoyancyProgram.uniforms.buoyancy, config.BUOYANCY);\n    gl.uniform1f(buoyancyProgram.uniforms.dt, dt);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Dissipate some pressure to give the illusion of an open box.\n    clearProgram.bind();\n    let pressureTexId = pressure.read.texId;\n    gl.activeTexture(gl.TEXTURE0 + pressureTexId);\n    gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);\n    gl.uniform1i(clearProgram.uniforms.uTexture, pressureTexId);\n    gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION);\n    blit(pressure.write.fbo);\n    pressure.swap();\n\n    // Projection step.\n    gl.viewport(0, 0, simWidth, simHeight);\n    // Compute velocity divergence field.\n    divergenceProgram.bind();\n    gl.uniform2f(divergenceProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.texId);\n    blit(divergence.fbo);\n    // Solve for pressure field with Jacobi iteration.\n    pressureIterationProgram.bind();\n    gl.uniform1i(pressureIterationProgram.uniforms.uPressure, pressureTexId);\n    gl.uniform2f(pressureIterationProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(pressureIterationProgram.uniforms.uDivergence, divergence.texId);\n\n    for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {\n      gl.bindTexture(gl.TEXTURE_2D, pressure.read.texture);\n      blit(pressure.write.fbo);\n      pressure.swap();\n    }\n    // Subtract pressure gradient from velocity field to project.\n    projectionProgram.bind();\n    gl.uniform2f(projectionProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1i(projectionProgram.uniforms.uPressure, pressure.read.texId);\n    gl.uniform1i(projectionProgram.uniforms.uVelocity, velocity.read.texId);\n    blit(velocity.write.fbo);\n    velocity.swap();\n\n    // Advect density (color) through the velocity field.\n    advectionProgram.bind();\n    gl.viewport(0, 0, dyeWidth, dyeHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / dyeWidth, 1.0 / dyeHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.texId);\n    gl.uniform1i(advectionProgram.uniforms.uSource, density.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);\n    blit(density.write.fbo);\n    density.swap();\n    // Advect temperature.\n    gl.viewport(0, 0, simWidth, simHeight);\n    if (!ext.supportLinearFiltering) {\n      gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1.0 / simWidth, 1.0 / simHeight);\n    }\n    gl.uniform1i(advectionProgram.uniforms.uSource, temperature.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, 1.0);\n    blit(temperature.write.fbo);\n    temperature.swap();\n    // Advect fuel.\n    gl.uniform1i(advectionProgram.uniforms.uSource, fuel.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, config.FUEL_DISSIPATION);\n    blit(fuel.write.fbo);\n    fuel.swap();\n    // Advect noise.\n    gl.uniform1i(advectionProgram.uniforms.uSource, noise.read.texId);\n    gl.uniform1f(advectionProgram.uniforms.dissipation, 1.0);\n    blit(noise.write.fbo);\n    noise.swap();\n\n    // Blend in some noise to the noise channel.\n    addNoiseProgram.bind();\n    gl.uniform2f(addNoiseProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n    gl.uniform1f(addNoiseProgram.uniforms.time, (new Date()).getTime() / 1.e4 % 1);\n    gl.uniform1i(addNoiseProgram.uniforms.uTarget, noise.read.texId);\n    gl.uniform1f(addNoiseProgram.uniforms.blendLevel, config.NOISE_VOLATILITY);\n    blit(noise.write.fbo);\n    noise.swap();\n\n    fireSources.forEach(fireSource => fireSource.step(dt));\n  }\n\n  canvas.addEventListener('mousemove', (e) => {\n    pointers[0].moved = pointers[0].down;\n    pointers[0].dx = (e.offsetX - pointers[0].x) * 5.0;\n    pointers[0].dy = (e.offsetY - pointers[0].y) * 5.0;\n    pointers[0].x = e.offsetX;\n    pointers[0].y = e.offsetY;\n  });\n\n  canvas.addEventListener('touchmove', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      let pointer = pointers[i];\n      pointer.moved = pointer.down;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointer.dx = (offsetX - pointer.x) * 8.0;\n      pointer.dy = (offsetY - pointer.y) * 8.0;\n      pointer.x = offsetX;\n      pointer.y = offsetY;\n    }\n  }, false);\n\n  canvas.addEventListener('mousedown', (e) => {\n    pointers[0].down = true;\n    pointers[0].color = {\n      r: 1.0,\n      g: 1.0,\n      b: 1.0\n    };\n    e.preventDefault();\n  });\n\n  canvas.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    const touches = e.targetTouches;\n    for (let i = 0; i < touches.length; i++) {\n      if (i >= pointers.length) {\n        pointers.push(new pointerPrototype());\n      }\n\n      pointers[i].id = touches[i].identifier;\n      pointers[i].down = true;\n      const offsetX = touches[i].clientX - canvas.getBoundingClientRect().x;\n      const offsetY = touches[i].clientY - canvas.getBoundingClientRect().y;\n      pointers[i].x = offsetX;\n      pointers[i].y = offsetY;\n      pointers[i].color = {\n        r: 0.5,\n        g: 0.5,\n        b: 0.5\n      };\n    }\n  });\n\n  window.addEventListener('mouseup', () => {\n    pointers[0].down = false;\n  });\n\n  window.addEventListener('touchend', (e) => {\n    const touches = e.changedTouches;\n    for (let i = 0; i < touches.length; i++)\n      for (let j = 0; j < pointers.length; j++)\n        if (touches[i].identifier == pointers[j].id)\n          pointers[j].down = false;\n  });\n\n  window.addEventListener('keydown', (e) => {\n    if (e.key === \" \") {\n      config.DISPLAY_MODE = (config.DISPLAY_MODE + 1) % DISPLAY_MODES.length;\n    }\n  });\n\n  advectionProgram =\n    new GLProgram(\n      shaders.baseVertexShader,\n      ext.supportLinearFiltering ? shaders.advectionShader : shaders.advectionManualFilteringShader\n    );\n  addNoiseProgram           = new GLProgram(shaders.baseVertexShader, shaders.addNoiseShader);\n  buoyancyProgram           = new GLProgram(shaders.baseVertexShader, shaders.buoyancyShader);\n  clearProgram              = new GLProgram(shaders.baseVertexShader, shaders.clearShader);\n  combustionProgram         = new GLProgram(shaders.baseVertexShader, shaders.combustionShader);\n  curlProgram               = new GLProgram(shaders.baseVertexShader, shaders.curlShader);\n  debugFireProgram          = new GLProgram(shaders.baseVertexShader, shaders.debugFireShader);\n  debugFloatProgram         = new GLProgram(shaders.baseVertexShader, shaders.debugFloatShader);\n  displayProgram            = new GLProgram(shaders.baseVertexShader, shaders.displayShader);\n  displayFireProgram        = new GLProgram(shaders.baseVertexShader, shaders.displayFireShader);\n  divergenceProgram         = new GLProgram(shaders.baseVertexShader, shaders.divergenceShader);\n  particlesAdvectionProgram = new GLProgram(shaders.baseVertexShader, shaders.particlesAdvectionShader);\n  particlesRenderProgram    = new GLProgram(shaders.particlesVertexShader, shaders.particlesRenderShader);\n  particlesResetDataProgram = new GLProgram(shaders.baseVertexShader, shaders.particlesResetDataShader);\n  particlesResetLifespanProgram = new GLProgram(shaders.baseVertexShader, shaders.particlesResetLifespanShader);\n  particlesStepLifespanProgram = new GLProgram(shaders.baseVertexShader, shaders.particlesStepLifespanShader);\n  pressureIterationProgram  = new GLProgram(shaders.baseVertexShader, shaders.pressureIterationShader);\n  projectionProgram         = new GLProgram(shaders.baseVertexShader, shaders.projectionShader);\n  rowProgram                = new GLProgram(shaders.baseVertexShader, shaders.rowShader);\n  splatProgram              = new GLProgram(shaders.baseVertexShader, shaders.splatShader);\n  vorticityConfinementProgram = new GLProgram(shaders.baseVertexShader, shaders.vorticityConfinementShader);\n\n  initFramebuffers();\n\n  // Initialize the noise channel.\n  addNoiseProgram.bind();\n  gl.uniform2f(addNoiseProgram.uniforms.texelSize, 1.0 / simWidth, 1.0 / simHeight);\n  gl.uniform1f(addNoiseProgram.uniforms.time, (new Date()).getTime() / 1.e6 % 1);\n  gl.uniform1i(addNoiseProgram.uniforms.uTarget, noise.read.texId);\n  gl.uniform1f(addNoiseProgram.uniforms.blendLevel, 1.0);\n  blit(noise.write.fbo);\n  noise.swap();\n\n  update();\n}", "import { makeFireSimulation, makeVorticitySimulation, makeSmokeSimulation, makeVelocityFieldSimulation, makeVectorFieldGridDiagram } from \"./demos\";\n\nmakeVectorFieldGridDiagram(document.getElementById(\"demo-grid\"));\nmakeVelocityFieldSimulation(document.getElementById(\"velocity-canvas\"));\nmakeVorticitySimulation(document.getElementById(\"vorticity-canvas\"));\nmakeSmokeSimulation(document.getElementById(\"smoke-canvas\"));\nmakeFireSimulation(document.getElementById(\"fire-canvas\"));"],
  "mappings": "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",
  "names": []
}
